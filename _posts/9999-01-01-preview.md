## About Vue

.self 자식영역제외 본인의 영역만 클릭했을 때 동작(target, currentTarget 이 같은 때)

.passive 이벤트와 리스너에 달린 로직적 부분을 분리해서 사용 가능하다.

.lazy v-model 에서 변화가 끝나면 감지하기 change 이벤트와 유사동작

inheritAttrs: false 기본 상속 안 받는다.

요청과 응답 get, post, body-parseri

provide() /inject: []

```js
import {computed} from 'vue'

provide() {
    return {
        msg: computed(() => return this.message)
    }
}

inject: ['msg']
```

hashchange

composition api 관심사 집중을 할 수 있음 - 항상 옳은건 아닙니다.

```js
import { ref } from "vue";

export default {
  setup() {
    let count = ref(0);
    function increase() {
      count.value += 1;
    }

    let message = ref("Hi");
  },
};
```

nuxt: layout > page > component

json-server

비동기 데이터 호출 방법: asyncData(https://joshua1988.github.io/vue-camp/nuxt/data-fetching.html) pages 안에서만 사용이 가능하다.

eslint fix 안될 때

```js
// nuxt.config.js
eslint: {
  fix: true
},
```

require 로 동적으로 호출한 파일을 찾지 못 할 때 webpack에서 로더의 esModule 을 false 로 설정해야한다.

```js
use: [
  {
    loader: 'file-loader',
    options: {
      esModule: false,
    },
  },
],
```

nuxt-heroku 에 배포시 setting의 config vars 에서 HOST 대소문자 주의
my-json-server 짱짱맨

nuxt에서 전역에다가 스타일 넣기 style-resources

## 아키텍쳐

점진적 적용, 종속성 관리, 아키텍쳐

- 유형별 분리: HTML, CSS, Code, Data, Rule, State,
- 변형 주기
- 오너쉽: Library, Framework, Service
- 위치: 내, 외부

스케일이 커져도 복잡도는 유지하려는 아키텍쳐를 가지려 함

- DOM은 이게 ㅈㄴ게 힘듬

## About UML

state machine

1. 분석
   - 요구사항
2. 설계: 기획, 모델링
   - 구조에 대한 설계: 클래스 다이어그램 ERD, UML
   - 동작에 대한 설계: 순서도, UML
   - Activity, class, cummunication, component, deploy

- Activity

  - 프로세스 중심적
  - 분석에 사용
  - Aggregation(하위가 독자적으로 존재 가능), Composition(하위가 캐스캐이딩)
  - Depend(인자로 사용됨), Use(상태를 가져다 쓸 때)

- Sequence

## About functional js

### 지연성2

reduce, take, find 는 결과를 만드는 함수.
map, filter 는 원소들에게 함수들을 합성하는 역할?

객체지향이 데이터의 구조를 우선시 하는 경향이 있다면
함수지향의 경우 함수에 맞는 데이터를 작성하려 한다.

```js
L.entries = function *(obj) {
  for (const key in obj) {
    yield [key, obj[key]];
  }
};

const join = curry((sep = ",", iter) => {
  reduce((acc, cur) => `${acc}${sep}${cur}`, iter);
});

const queryStr = pipe(
  L.entries,
  L.map(([key, value]) => `${key}=${value}`),
  join("&")
);

const find = curry((f, iter) => go{
  iter,
  L.filter(f),
  take(1),
  ([a]) => a
});

console.log(
  queryStr({
    name: "aredra",
    age: 20,
  })
);

const takeAll = take(Number.POSITIVE_INFINITY);
const isIterable = a => a && a[Symbol.iterator];

L.flatten = function *f(iter) {
  for (const x of iter) {
    if (isIterable(x)) {
      yield *f(x) ;
    } else {
      yield x;
    }
  }
};

const flatten = pipe(
  L.flatten,
  takeAll
);
```
