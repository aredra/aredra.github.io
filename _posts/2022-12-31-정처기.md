---
title: "정보처리기사 - 정리"
date: 2022-12-31
comments: false
read_time: false
toc: true
categories:
  - 정보처리기사
tags:
  - 정보처리기사
---

# 원문, 출처 : [별의 블로그](https://starrykss.tistory.com/1856)

# 1. 요구사항 확인

## 소프트웨어 생명주기 모델

- 소프트웨어 생명주기: 시스템의 요구분석부터 유지보수까지 전 공정을 체계화한 절차
- 시스템이 개발될 때부터 운용과 유지보수를 거쳐 생애를 마칠 때까지 어떠한 순서를 밟는지에 대한 작업 프로세스를 모델화 한 것
- 프로세스
  - 요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수
- 모델 종류
  - 폭포수 모델: 각 단계를 확실히 마무리 지은 후 다음 단계로 넘어가는 모델
    - 타당성 검토 -> 계획 -> 요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수
  - 프로토타이핑 모델: 고객이 요구한 주요기능을 프로토타입을 구현 후 피드백을 반영하며 만들어가는 모델
  - 나선형 모델: 시스템 개발 시 위험을 취소화하기 위해 점진적으로 완벽한 시스템으로 개발하는 모델
    - 계획 및 정의 -> 위험 분석 -> 개발 -> 고객 평가
  - 반복적 모델: 구축 대상을 나누어 병렬적으로 개발 후 통합하거나, 반복적으로 개발하여 점진적으로 완성시키는 모델

## 소프트웨어 개발 방법론

- 소프트웨어 개발 전 과정에 지속적으로 적용할 수 방법, 절차, 기법
  - 구조적 방법론: 전체 시스템을 기능에 따라 나누어 개발, 이를 통합하는 분할과 정복 접근 방식의 방법론
  - 정보공학 방법론: 정보 시스템 개발에 필요한 관리 절차와 작업 기법을 체계화한 방법론
  - 객체 지향 방법론: '객체'라는 기본 단위로 시스템을 분석 및 설계하는 방법론
  - 컴포넌트 기반 방법론: 소프트웨어를 구성하는 컴포넌트를 조립해서 하나의 새로운 응용 프로그램을 작성하는 방법론
  - 애자일 방법론: 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적용하며, 효율적으로 개발할 수 있는 **신속 적응적 경량 개발 방법론**
  - 제품 계열 방법론: 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론

## 애자일 방법론 기법

- XP(extreme Programming): 의사소통 개선과 즉각적 피드백으로 소프트웨어 품질을 높이기 위한 방법론
  - 5가지 가치
    - 용기, 단순성, 의사소통, 존중, 피드백
  - 12가지 원리
    - 짝 프로그래밍
    - 공동 코드 소유
    - 지속적인 통합
    - 계획 세우기
    - 작은 릴리즈
    - 메타포어
    - 간단한 디자인
    - 테스트 기반 개발
    - 리팩토링
    - 40시간 작업
    - 고객 상주
    - 코드 표준
- 스크럼: 매일 정해진 시간, 장소에서 짧은 시간의 개발을 하는 팀을 위한 프로젝트 관리 중심 방법론
  - 백로그: 제품과 프로젝트에 대한 요구사항
  - 스프린트: 2~4주의 짧은 개발 기간의 반복적 수행으로 개발품질 향상
  - 스크럼 미팅: 매일 15분 정도 미팅으로 To-Do list 계획 수립
  - 스크럼 마스터: 프로젝트 리더, 스크럼 수행 시 문제 인지 및 해결하는 사람
  - 스프린트 회고: 스프린트 주기를 되돌아보며 정해놓은 규칙 준수 엽, 개선점 등을 확인 및 기록
  - 번 다운 차트: 남아있는 백로그 대비 시간을 시각적으로 표현한 차트
- 린: 도요타의 린 시스템 품질기법을 소프트웨어 개발 프로세스에 적용해서 낭비 요소를 제거하여 품질을 향상시킨 방법
  - JIT, 칸반 보드 사용
  - 7가지 원칙
    - 낭비 제거
    - 품질 내재화
    - 지식 창출
    - 늦은 확정
    - 빠른 인도
    - 사람 존중
    - 전체 최적화

## 객체 지향 분석

- 사용자의 요구사항을 분석하여 요구된 문제와 관련된 모든 클래스, 속성, 연산, 관계를 정의하여 모델링하는 기법
- 종류
  - OOSE: 야콥슨, 유스케이스에 의한 접근 방법으로 유스케이스를 모든 모델의 근간으로 활용하는 방법론, 야콥슨
  - OMT: 럼바우, 그래픽 표기법을 이용하여 소프트웨어 구성요소를 모델링하는 방법론
    - 객체 모델링: 객체 다이어그램 활용
    - 동적 모델링: 시간의 흐름에 따라 객체들 사이의 제어 흐름, 동작 순서 등의 동적인 행위를 표현, 상태 다이어그램
    - 기능 모델링: 프로세스의 자료 흐름을 중심으로 처리 과정 표현, 자료 흐름도 활용
  - OOD: 부치, 설계 문서화를 강조하여 다이어그램 중심으로 개발하는 방법론

## 비용 산정 모형

- 소프트웨어 규모 파악을 통한 투입자원, 소요시간을 파악하여 실행 가능한 계획을 수립하기 위해 비용을 산정하는 방식
- 하향식 산정 방법
  - 전문가 판단
  - 델파이 기법
- 상향식 산정 방법
  - 코드 라인 수(LoC): 소프트웨어 각 기능의 원시 코드 라인 수의 낙관치, 중간치, 비관치를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 방식
  - Man Month: 한 사람이 1개월 동안 할 수 있는 일의 양을 기준으로 프로젝트 비용을 산정하는 방식
  - COCOMO 모형: 보헴, 비용산정 결과는 프로젝트를 완성하는 데 필요한 노력으로 산정
    - 조직형: 5만 라인 이하
    - 반 분리형: 30만 라인 이하
    - 임베디드형: 30만 라인 초과
  - Putnam 모형: 생명주기 예측 모형, 각 단계별로 요구할 인력의 분포를 가정하는 방식
  - FP 모형: 요구 기능을 증가시키는 인자별로 가중치를 부여하고, 요인별 가중치를 합산하여 총 기능의 점수를 계산하여 비용을 산정하는 방식

## 일정 관리 모델

- 프로젝트가 일정 기한 내에 적절하게 완료도리 수 있도록 관리하는 모델
- 주 공정법(CPM): 여러가지 수행 순서가 얽혀 있는 프로젝트의 일정을 계산하는 방법, 가장 긴 시간이 걸리는 경로를 계산한다.
- PERT(Program Evaluation and Review Technique): 일의 순서를 계획적으로 정리하기 위한 수렴 기법 3점 추정방식을 통해 일정을 관리하는 기법
- 중요 연쇄 프로젝트 관리(CCPM): 주 공정 연쇄법으로 자원 제약 사항을 고려하여 일정을 작성하는 기법

## 소프트웨어 아키텍쳐 4+1뷰

- 고객의 요구사항을 정리해 놓은 시나리오를 4개의 관점에서 바라보는 소프트웨어적인 접근 방식
- 체크 방법으로 유스케이스를 사용한다.
  - 유스케이스: 시스템이 엑터에게 제공해야 하는 기능으로서 시스템의 요구사항이자, 사용자 입장에서 바라본 시스템의 기능
- 1(유스케이스 뷰) + 4(논리 뷰, 프로세스 뷰, 구현 뷰, 배포 뷰)
- 유스케이스 뷰: 유스케이스 또는 아키텍처를 도출하고 설계하며 다른 뷰를 검증하는데 사용되는 뷰
  - 사용자/설계자/개발자/테스트 관점
- 논리 뷰: 시스템의 기능적인 요구사항이 어떻게 제공되는지 설명해주는 뷰
  - 설계자/개발자 관점
- 프로세스 뷰: 시스템의 비기능적인 속성으로서 자원의 효율적인 사용, 병행 실행, 비동기, 이벤트 처리 등을 표현한 뷰
  - 개발자/시스템 통합자 관점
- 구현 뷰: 개발 환경 안에서 정적인 소프트웨어 모듈의 구성을 보여주는 뷰
- 배포 뷰: 컴포넌트가 물리적인 아키텍처에 어떻게 배치되는가를 매핑해주는 뷰

## 소프트웨어 아키텍처 패턴

- 소프트웨어를 설계할 때 참조할 수 있는 전형적인 해결 방식
- 계층화 패턴: 시스템을 계층으로 구분하여 구성하는 패턴
- 클라이언트-서버 패턴: 하나의 서버와 다수의 클라이언트로 구성된 패턴
- 파이프-필터 패턴: 데이터 스트림을 생성하고 처리하는 시스템에서 사용 가능한 패턴
- 브로커 패턴: 분리된 컴포넌트들로 이루어진 분산 시스템에서 사용되고, 이 컴포넌트들은 원격 서비스 실행을 통해 상호 작용이 가능한 패턴
- 모델-뷰-컨트롤러 패턴: 대화형 어플리케이션을 모델, 뷰, 컨트롤러의 3개의 서비 시스템으로 구조화하는 패턴

## 소프트웨어 아키텍처 비용 평가 모델

- 아키텍처 접근벙이 품질 속성에 미치는 영향을 판단하고 아키텍처의 적합성을 평가하는 모델
- SACAA
  - SAAM: 변경 용이성과 기능성에 집중, 평가가 용이하며 경험이 없는 조직에서도 활용 가능한 비용 평가 모델
  - ATAM: 아키텍처 품질 속성을 만족시키는지 판단 및 품질 속성들의 이해 상충관계가지 평가하는 모델
  - CBAM: ATAM 바탕의 시스템 아키텍처 분석 중심으로 경제적 의사결정에 대한 요구를 충족하는 비용 평가 모델
  - ADR: 소프트웨어 아키텍처 구성요소 간 응집도를 평가하는 모델
  - ARID: 전체 아키첵처가 아닌 특정 부분에 대한 품질요소에 집중하는 비용 평가 모델

## 디자인 패턴

- 소프트웨어 공학의 스프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 패턴
- 디자인 패턴의 구성요소
  - 패턴의 이름
  - 문제 및 배경
  - 솔루션
  - 사례
  - 결과
  - 샘플코드
- 디자인 패턴 유형
  - 목적에 따른 구분: 생성, 구조, 행위
  - 범위에 따른 구분: 클래스, 객체
  - 생성 패턴: 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행하는 패턴
    - Builder: 복잡한 인스턴스를 조립하여 만드는 구조
    - Prototype: 처음부터 일반적인 원형을 만들어 놓고, 그것을 복사한 후 필요한 부분만 수정하여 사용하는 패턴
    - Factory Method: 상위 클래스에서 객체를 생헝하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 하는 방식
    - Abstract Factory: 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴
    - Singleton: 전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객첼르 어디에서든지 참조할 수 있도록 하는 패턴
  - 구조 패턴: 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴
    - Bridge: 기능의 클래스 계층과 구현의 클래스 계층을 연결하고, 구현부에서 추상 계층을 분리하여 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있는 패턴
    - Decorator: 기존에 구현되어 있는 클래스에 필요한 기능을 추가해 나가는 패턴
    - Facade: 단순한 인터페이스를 제공함으로서, 노드 간 결합도를 낮추어 시스템 구조에 대한 파악을 쉽게 하는 패턴
    - Flyweight: 클래스 경량화를 목적으로 하는 패턴, 여러 개의 가상 인스턴스를 제공하여 메모리를 절감
    - Proxy: 실제 객체에 대한 대리 객체, 실제 객체 접근 이전에 필요한 행동을 할 수 있음. 정보 은닉의 역할도 수행하는 패턴
    - Composite: 객체들의 관계를 트리 구조로 구성하여, 부분-전체 계층을 표현하는 패턴
    - Adapter: 기존에 생성된 클래스를 재사용 할 수 있도록 중간에서 맞춰주는 역할을 하는 인터페이스를 만드는 패턴
  - 행위 패턴: 클래스나 객체들이 상호 작용하는 방법과 역할 분담을 다루는 패턴
    - Mediator: 중재자를 두고, 중재자에게 모든 것을 요구하여 통신의 빈도수를 줄여 객체 지향의 목표를 달성하는 패턴
    - Interpreter: 구체적으로 구문을 나누고 그 분리된 구문의 해석을 맡는 클래스를 작성하여 여러 형태의 구문을 해석할 수 있게 하는 패턴
    - Iterator: 컬렉션의 구현 방법을 노출시키지 않으면서 안에 들어있는 모든 항목에 접근할 방법을 제공하는 디자인 패턴
    - Template Method: 작업의 일부분을 서브 클래스로 캡슐화 하여 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴
    - Observer: 일대 다의 의존성을 가지며, 상호 작용을 하는 객체 사이에서는 가능하면 느슨하게 결합하는 패턴
    - State: 객체 상태를 캡슐화하여 클래스화 함.
    - Visitor: 각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도의 클래스를 만들고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 하는 패턴
    - Command: 각 명령이 들어오면 그에 맞는 서브 클래스가 선택되어 실행되는 특징을 갖는 패턴
    - Strategy: 알고리즘 군을 정의하고, 같은 알고리즘을 각각의 클래스로 캡슐화한 다음, 필요할 때 서로 교환해서 사용할 수 있게 하는 패턴
    - Memento: 클래스 설계 관점에서 객체의 정보를 저장할 필요가 있을 때 적용하는 패턴
    - Chain of Responsibility: 연결되어 있는 경우에 따라 동적으로 다르게 처리될 수 있도록 연결한 패턴

## 분석 산출물의 종류

- 정보 시스템 구성 현황
- 정보 시스템 기능 구성도
- 인터페이스 현황
- 현행 시스템 아키텍처 구성도
- 소프트웨어 구성도
- 하드웨어 구성도
- 네트워크 구성도

## OS

- 컴퓨터 시스템이 제공하는 모든 하드웨어, 소프트웨어를 사용할 수 있게 해주고, 사용자와 하드웨어 간의 인터페이스를 담당하는 프로그램
- 신뢰도, 성능, 기술지원, 주변기기, 구축비용

## OSI 7계층

- 물리 계층: 0, 1 비트 정보를 회선에서 보내기 위한 전기적 신호 변환
  - 프로토콜: RS-232C
  - 전송단위: 비트
- 데이터 링크 계층: 데이터 전송 제어
  - 프로토콜: 이더넷
  - 전송단위: 프레임
- 네트워크 계층: 단말 간 데이터 전송의 최적 경로를 제공
  - 프로토콜: IP, ICMP
  - 전송단위: 패킷
- 전송 계층: 신뢰성 있는 통신 보장, 데이터 분할과 재조립, 흐름, 오류, 혼잡 제어
  - 프로토콜: TCP, UDP
  - 전송단위: 세그먼트
- 세션 계층: 연결 접속 및 동기 제어
  - 프로토콜: SSH, TLS
  - 전송단위: 데이터
- 표현 계층: 데이터 형식 설정과 부호 교환, 암/복호화
  - 프로토콜: JPEG, MPEG
  - 전송단위: 데이터
- 응용 계층: 사용자와 네트워크 간 응용서비스 연결
  - 프로토콜: FTP, SMTP, HTTP, HTTPS
  - 전송단위: 데이터

## DBMS 현행 시스템 분석 시 고려사항

- 가용성
- 성능
- 상호 호환성
- 기술지원
- 구축비용

## 미들웨어

- 분산 컴퓨팅 환경에서 응용 프로그램과 프로그램이 운영되는 환경 간에 원만한 통신이 이루어질 수 있도록 제어해주는 소프트웨어
- 운영체제와 소프트웨어 어플리케이션 사이에 위치

### WAS

- 서버 계층에서 어플리케이션이 동작할 수 있는 환경을 제공하고 안정적인 트랜잭션 처리와 관리, 다른 이기종 시스테모가의 어플리케이션 연동을 지원

## 요구공학

- 사용자의 요구가 반영된 시스템을 개발하기 위해 사용자 요구사항에 대한 도출, 분석, 명세, 확인 하는 구조화된 활동
- 기능적 요구사항, 비기능적 요구사항

## 요구사항 개발 단계 상세

- 요구사항 도출 관계 주요 기법
  - 인터뷰
  - 브레인스토밍
  - 델파이 기법
  - 롤 플레잉
  - 워크숍
  - 설문조사
- 요구사항 분석 단계 절차
  - 요구사항 분류
  - 개념 모델링 생성 및 분석
  - 요구사항 할당
  - 요구사항 협상
  - 정형 분석
  - 자료 흐름 지향 분석
  - 객체 지향 분석
- 요구사항 명세 단계 주요 기법
  - 비정형, 정형 명세 기법
  - 명확성
  - 완전성
  - 검증 가능성
  - 일관성
  - 수정 용이성
  - 추적 가능성
  - 개발 후 이용성
- 요구사항 확인 단계의 주요 기법
  - 정형 기술 검토 활용
    - 동료 검토
    - 워크 스루
    - 인스펙션
  - 프로토타이핑 활용
  - 모델 검증
  - 테스트 케이스 및 테스트를 통한 확인
  - CASE 도구 활용 검증
  - 요구사항 추적표를 통한 검증
- 상세 정형 기술 검토 기법
  - 관리 리뷰
  - 기술 리뷰
  - 인스펙션
  - 워크 스루
  - 감사

# 2. 데이터 입출력 구현

## 데이터 모델 표시 요소

- 연산: 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세
- 구조: 데이터베이스에 논리적으로 표현될 대상으로서의 개체 타입과 개체 타입 간의 조절
- 제약 조건: 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건

## 데이터 모델 절차

- 요구사항 분석
- 개념적 설계: 사용자의 트랜잭션을 모델링 하는 관계
- 논리적 설계: 트랜잭션의 인터페이스르 설계하는 단계
- 물리적 설계: 논리 데이터 모델을 특정 DBMS 특성 및 성능을 고려하여 물리적인 스키마를 만드는 단계

## 논리 데이터 모델링 속성

- 개체: 관리할 대상이 되는 실체
- 속성: 관리할 정보의 구체적 항목
- 관계: 개체간의 대응 관계

## ER 모델

- 현실 세계에 존재하는 데이터와 그들 간의 관계를 사람이 이해할 수 있는 형태로 명확하게 표현하기 위해서 가장 널리 사용되고 있는 모델

## 정규화

- 관게형 데이터 모델에서 데이터의 중복성을 제거하여 이상 현상을 방지하고, 데이터의 일관성 과 정확성을 유지하기 위해 무손실 분해하는 과정
- 정규화 단계
  - 1정규형: 원자값으로 구성
  - 2정규형: 부분 함수 종속 제거
  - 3정규형: 이행 함수 종속 제거
  - BCNF: 결정자 후보키가 아닌 함수 종속 제거
  - 4정규형: 다중 값 종속 제거
  - 5정규형: 조인 종속 제거

## 이상 현상

- 데이터의 중복성으로 인해 린레잇녀을 조작할 때 발생하는 비합리적인 현상
- 삽입 이상: 정보 저장 시 해당 정보의 불필요한 세부정보를 입력해야 되는 경우
- 삭제 이상: 정보 삭제 시 원치 않는 다른 정보가 같이 삭제되는 경우
- 갱신 이상: 중복 데이터 중 특정 부분만 수정되어 중복된 값이 모순을 일으키는 경우

## 반 정규화

- 정규화된 개체, 속성, 관계에 대해 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법
- 기법
  - 테이블 병합
  - 테이블 분할
  - 중복 테이블 추가
  - 컬럼 중복화
  - 중복 관계 추가

## 인덱스

- 검색 연산의 최적화를 위해 데이터베이스 내 열에 대한 정보를 구성한 데이터 구조
- 종류
  - 순서 인덱스: 데이터가 정렬된 순서로 생성되는 인덱스
  - 해시 인덱스: 해시 함수에 의해 직접 데이터에 키 값으로 접근하는 인덱스
  - 비트맵 인덱스: 각 컬럼에 적은 개수 값이 저장된 경우 선택하는 인덱스
  - 함수기반 인덱스: 수식이나 함수를 적용하여 만든 인덱스
  - 단일 인덱스: 하나의 컬럼으로만 구성한 인덱스
  - 결합 인덱스: 두 개 이상의 컬럼으로 구성한 인덱스
  - 클러스터드 인덱스: 기본 키 기준으로 레코드를 묶어서 저장하는 인덱스

### 인덱스 스캔 방식

- 인덱스 범위 스캔
- 인덱스 전체 스캔
- 인덱스 단일 스캔
- 인덱스 생략 스캔

## 파티션

- 종류
  - 레인지 파티셔닝: 연속적인 숫자나 날짜를 기준
  - 해시 파티셔닝: 파티션 키의 해시 값에 의한 파티셔닝
  - 리스트 파티셔닝: 특정 파티션에 저장 될 데이터에 대한 명시적 제어가 가능한 파티셔닝
  - 컴포지트 파티셔닝: 2개 이상의 파티셔닝을 결합하는 파티셔닝
  - 라운드로빈 파티셔닝: 라운드로빈 분할로 회전하면서 새로운 행이 파티션에 할당
- 장점
  - 성능 향상
  - 가용성 향상
  - 백업 가능
  - 경합 감소

## 데이터베이스

- 다수의 인원, 시스템 또는 프로그램이 사용할 목적으로 통합되어 관리되는 데이터 집합
- 정의
  - 통합된 데이터: 자료의 중복을 배제한 데이터 모임
  - 저장된 데이터: 저장 매체에 저장된 데이터
  - 운영 데이터: 조직의 업무를 수행하는데 필요한 데이터
  - 공용 데이터: 여러 어플리케이션, 시스템들이 공동으로 사용하는 데이터
- 특성
  - 실시간 접근성
  - 계속적인 변화
  - 동시 공용
  - 내용 참조
- 종류
  - 파일 시스템: ISAM, VSAM
  - RDBMS
  - 계층형 데이터베이스 관리 시스템(HDBMS): 데이터를 상하 종속적인 관계로 계층화하여 관리하는 데이터베이스
  - 네트워크 데이터베이스 관리 시스템(NDBMS): 데이터의 구조를 네트워크의 망상 형태로 표현한 데이터 모델

## DBMS

- 데이터 관리의 복잡성을 해결하는 동시에 데이터 추가, 변경, 검색, 삭제 및 백업, 복구, 보안 등의 기능을 지원하는 소프트웨어
- 유형
  - 키-값
  - 컬럼 기반 데이터 저장
  - 문서 저장
  - 그래프
- 특징

  - 일관성
  - 무결성
  - 회복성
  - 보안성
  - 효율성

  ## 빅 데이터

  - 주어진 비용, 시간 내에 처리 가능한 데이터 범위를 넘어서는 수십 페타 크기의 비정형 데이터
  - 특성
    - 데이터의 양(Volume)
    - 데이터의 다양성(Variety)
    - 데이터의 속도(Velocity)
    - 데이터의 진실성(Veracity)
    - 데이터의 가치(Value)
    - 데이터의 정확성(Validity)
    - 데이터의 휘발성(Volatility)

## NoSQL

- 데이터 저장에 고정된 테이블 스키마가 필요하지 않고 조인 연산을 사용할 수 없는 수평적으로 확장이 가능한 DBMS

## 데이터 마이닝

- 대규모로 저장된 데이터 안에서 체계적이고 자동적으로 통계적 규칙이나 패턴을 찾아내는 기술
- 기법
  - 분류 규칙: 과거 데이터로부터 특성을 찾아내어 분류모형을 만들어 이를 토대로 새로운 레코드의 결과값을 예측하는 기법
  - 연관 규칙: 데이터 안에 존재하는 항목들 간의 종속 관계를 찾아내는 기법
  - 연속 규칙: 연관 규칙에 시간 관련 정보가 포함된 형태의 기법
  - 데이터 군집화: 대상 레코드들을 유사한 특성을 지닌 몇 개의 소그룹으로 분할하는 작업

## 관계 대수

- 관계형 데이터베이스에서 원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 절차적 정형 언어

### 일반 집합 연산자

- 합집합
- 교집합
- 차집합
- 카티션 프로덕트

### 순수 관계 연산자

- 셀렉트
- 프로젝트
- 조인
- 디비전

# 3. 통합 구현

## XML(eXtensible Markup Language)

- 특수한 목적을 갖는 마크업 언어를 만드는 데 사용되는 다목적 마크업 언어
- 사용자가 직접 문서의 태그를 정의할 수 있으며, 다른 사용자가 정의한 태그를 사용할 수 있다.
- 트리 구조로 구성되어 있어 상위 태그는 여러 개의 하위 태그를 가질 수 있다.

## SOAP(Simple Object Access Protocol)

- 네트워크 상에서 HTTP 등을 이용하여 XML 을 교환하기 위한 통신 규약
- 기본적으로 HTTP 기반에서 동작하기 때문에 프록시와 방화벽의 영향없이 통신할 수 있다.

## WSDL(Web Services Description Language)

- 웹 서비스와 관련된 서식이나 프로토콜 등을 표준적인 방법으로 기술하고 게시하기 위한 언어
- XML 로 작성되며, UDDI 의 기초가 된다.
- SOAP, XML 스키마와 결합하여 인터넷에서 웹 서비스를 제공하기 위해 사용된다.

# 4. 서버 프로그램 구현

## 개발 도구의 분류

- 빌드 도구: 작성한 코드의 빌드 및 배포를 수행하는 도구
- 구현 도구: 개발자의 코드 작성과 디버깅, 수정 등과 같은 작업을 지원하는 도구
- 테스트 도구: 코드의 기능 검증과 전체의 품질을 높이기 위해 사용하는 도구
- 형상 관리 도구: 개발자들이 작성한 코드와 리소스 등 산출물에 대한 버전 관리를 위한 도구

## 형상 관리

- 코드와 리소스 등 산출물에 대한 버전 관리를 위한 활동
- 절차
  - 형상 식별
  - 형상 통제
  - 형상 감사
  - 형상 기록
- 소프트웨어 형상 관리 도구 유형
  - 공유 폴더 방식(RCS)
  - 클라이언트/서버 방식(SVN)
  - 분산 저장소 방식(Git)
- 소프트웨어 형상 관리 도구별 특징
  - CVS: 서버와 클라이언트로 구성되어 있고, 다수의 인원이 동시에 범용적인 운영체제로 접근 가능한 관리 도구
  - SVN: 하나의 서버에서 소스를 쉽고 유용하게 관리할 수 있는 도구
  - RCS: 소스 파일의 수정을 한 사람만으로 제한하여 다수의 사람이 파일의 수정을 동시에 할 수 없도록 파일 잠금 방식으로 관리
  - Git: 속도에 중점을 둔 분산형 버전 관리 시스템
  - Clear case: 복수의 서버, 클라이언트 구조이며 확장성을 기할 수 있음

## 모듈

- 그 자체로 하나의 완전한 기능을 수행할 수 있는 독립된 실체

### 모듈화

- 소프트웨어의 성능을 향상시키거나 복잡한 시스템의 수정, 재사용, 유지 관리 등이 용이하도록 기능 단위의 모듈로 분해하는 설계 및 구현 기법
- 기법
  - 루틴: 특정 동작을 수행하는 일련의 코드로 기능을 가진 명령들의 모임
  - 메인 루틴, 서브 루틴

## 응집도

- 모듈의 독립성을 나타내는 정도로, 모듈 내부 구성요소간 연관 정도
- 유형
  - 우연적 응집도(Coincidental Cohesion): 모듈 내부의 각 구성요소가 연관이 없을 경우의 응집도
  - 논리적 응집도(Logical Cohesion): 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리
  - 시간적 응집도(Temporal Cohesion): 연관된 기능보다 특정 시간에 처리되어야 하는 활동들의 모음
  - 절차적 응집도(Procedural Cohesion): 다수의 관련 기능을 가질 때 모듈 안의 구성요소들이 그 기능을 순차적으로 수행할 경우
  - 통신적 응집도(Communication Cohesion): 동일한 입력돠 출력을 사용하여 다른 기능을 수행하는 활동들의 모음
  - 순차적 응집도(Sequential Cohesion): 모듈 내에서 한 활동으로부터 나온 출력값을 다른 활동들이 사용할 경우
  - 기능적 응집도(Functional Cohesion): 모든 기능이 단일한 목적을 위해 수행되는 경우

## 결합도

- 외부 모듈가의 연관성, 상호의존성
- 유형
  - 내용 결합도(Content Coupling): 모듈 내부의 변수나 기능을 다른 모듈에서 사용하는 경우
  - 공통 결합도(Common Coupling): 파라미터가 아닌 모듈 밖에 선언되어 있는 전역변수를 참조하고 갱식하는 식의 결합도
  - 외부 결합도(External Coupling): 모듈이 외부에서 도입된 데이터 포맷, 디바이스 인터페이스를 공유할 경우
  - 제어 결합도(Control Coupling): 모듈이 다른 모듈의 내부 논리 조직을 제어하기 위한 목적으로 제어 신호를 이용하여 통신하는 경우 결합도
  - 스탬프 결합도(Stamp Coupling): 모듈 간의 인터페이스로 배열이나 객체, 구조 등이 전달되는 경우
  - 자료 결합도(Data Coupling): 모듈 간 인터페이스로 전달되는 파라미터를 통해서만 모듈간 상호 작용이 일어나는 경우

## 팬인/ 팬아웃

- 팬인: 어떤 모듈을 제어하는 모듈의 수
- 팬아웃: 어떤 모들에 의해 제어되는 모듈의 수

## 공통 모듈 테스트

- 화이트박스 테스트: 응용프로그램 내부 구조와 동작을 검사하는 방식
- 메서드 기반 테스트: 공통 모듈의 외부에 공개된 메서드 기반의 테스트
- 화면 기반 테스트: 화면 단위로 단위 모듈을 개발 후 화면에 직접 데이터를 입력하여 테스트를 수행
- 테스트 드라이버/ 테스트 스텁 활용 테스트: 기능을 테스트 할 수 있는 화면 또는 하위 모듈이 구현되지 않은 경우 해당 기법 사용

## 배치 프로그램

- 사용자와의 상호 작용 없이 일련의 작업들을 작업 단위로 묶어 정기적으로 반복 수행하거나 정해진 규칙에 따라 일괄 처리하는 방식
- 유형
  - 이벤트 배치: 사전에 정의해 둔 조건 충족 시 자동으로 실행
  - 온디멘드 배치: 사용자의 명시적 요구가 있을 때 실행
  - 정기 배치: 정해진 시점에 정기적으로 실행

## 배치 스케줄러

- 일괄 처리를 위해 주기적으로 발생하거나 반복적으로 발생하는 작업을 지원하는 도구
- 종류
  - 스프링 배치
  - 쿼츠 스케줄러

## 크론 표현식

- 초/분/시/일/월/요/년

# 5. 인터페이스 구현

## 인터페이스 명세서

- 데이터의 송수신 시스템 간의 데이터 저장과 속성 등의 상세 내역을 포함

### 인터페이스 명세서 중요 항목

- 인터페이스 ID
- 최대 처리 횟수
- 데이터 크기
- 시스템 정보
- 데이터 정보

### 상세 기능별 인터페이스 명세서 주요 항목

- 인터페이스 ID
- 인터페이스명
- 오퍼레이션명
- 오퍼레이션 개요
- 사전 조건
- 사후 조건
- 파라미터
- 반환 값

## EAI(Enterprise Application Integration)

- 기업에서 운영되는 서로 다른 플랫폼 및 어플리케이션 간의 정보를 전달, 연계, 통합이 가능하도록 해주는 솔루션
- 구축 유형
  - 포인트 투 포인트: 기초적인 어플리케이션 통합 방법으로 1:1 단순 통합
  - 허브 앤 스포크: 단일한 접점의 허브 시스템을 통하여 데이터를 전송하는 중앙 집중식
  - 메시지 버스: 어플리케이션 사이 미들웨어를 두어 연계하는 미들웨어 통합 방식
  - 하이브리드: 그룹 내부는 허브 앤 스포크를 사용 그룹 간에는 메세지 버스 방식을 사용

## ESB(Enterprise Service Bus)

- 기업에서 운영되는 서로 다른 플랫폼 간을 하나의 시스템으로 관리 운영할 수 있도록 서비스 중심의 통합을 지향하는 아키텍처
- 버스를 중심으로 각각 프로토콜이 호환할 수 있도록 어플리케이션의 통합을 느슨한 결합 방식으로 지원

## JSON(JavaScript Object Notation)

- 키-값 쌍으로 이루어진 객체를 전달하기 위해 인간이 읽을 수 있는 텍스트를 사용하는 개병형 표준 포맷

## XML(eXtensible Markup Language)

- HTML의 단점을 보완한 인터넷 언어로 송수신 시스템 간 데이터 연계의 편의성을 위해서 전송되는 데이터 구조를 동일한 형태로 정의
- 사용자가 직접 문서의 태그를 정의할 수 있음

## AJAX(Asynchronous JavaScript And XML)

- 자바스크립트를 사용하여 비동기적으로 XML 데이터를 교환하고 조작하기 위한 웹 기술
- XMLHttpRequest 를 사용하여 페이지 전체가 아닌 일부 페이지 데이터만을 로드하는 기술
- 주요 기술
  - XMLHttpRequest
  - JavaScript
  - XML
  - DOM
  - XSLT
  - HTML
  - CSS

## REST(Representational State Transfer)

- 웹과 간은 분산 하이퍼미디어 환경에서 자원의 존재/상태 정보를 표준화된 HTTP 메서드로 주고 받는 웹 아키텍처
- 리소스, 메서드, 메시지 3가지 요소로 구성

## 시큐어 코딩 가이드 적용 대상

- 입력 데이터 검증 및 표현
- 보안 기능
- 시간 및 상태
- 에러 처리
- 코드 오류
- 캡슐화
- API 오용

## 데이터베이스 암호화 알고리즘 유형

- 대칭 키 암호화 알고리즘
  - 암복호화에 같은 암호 키를 쓰는 알고리즘
  - ARIA 128/192/256, SEED
- 비대칭 키 암호화 알고리즘
  - 공개키는 누구나 알 수 있지만 비밀키는 키 소유자만이 알 수 있도록, 공개키와 비밀키를 사용하는 알고리즘
  - RSA, ECC, ECDSA
- 해쉬 암호화 알고리즘
  - 해시값으로 원래 입력값을 찾아낼 수 없는 일방향성의 특성을 가진 알고리즘
  - SHA-256/384/512, HAS-160

## 데이터베이스 암호화 기법:

- API 방식: 어플리케이션 레벨에서 암호 모듈을 적용하는 방식
- Plug-in 방식: 암복호화 모듈이 DB 서버에 설치된 방식
- TDE 방식: DB의 DBMS 커널이 자체적으로 암복호화 기능을 수행하는 방식
- Hybrid 방식: API 방식과 Plug-in 방식을 혼합하여 사용하는 방식

## IPSec

- ip 계층에서 무결성과 인증을 보장하는 인증 해더와 기밀성을 보장하는 암호화를 이용하여 양 종단 간 구간에 보안
- 동작모드: 전송, 터널
- 프로토콜: AH, ESP, IKE
- 정책: SPD, SAD

## SSL/TLS

- 전송 계층과 응용 계층 사이에서 클라이언트와 서버 간의 웹 데이터 암호화, 상호 인증 및 전송시 데이터 무결성을 보장하는 프로토콜
- 인증 모드: 익명 몯, 서버 인증 모드, 클라이언트-서버 인증 모드

## S-HTTP

- 웹 상에서 네트워크 트래픽을 암호화하는 주요 방법 중 하나, 클라이언트-서버 간에 전송되는 모든 메시지를 각각 암호화하여 전송

## 인터페이스 구현 검증 도구

- XUnit: 다양한 언어를 지원하는 단위 테스트 프레임워크
- STAF: 서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원
- FitNesse: 웹 기반 테스트 케이스 설계, 실행, 결과 확인 등을 지원
- NTAF: FitNesse 의 장점인 협업기능과 STAF 장점인 재사용 및 확장성을 통한 NHN의 테스트 자동화 프레임워크
- Selenium: 다양한 브라우저 및 개발 언어를 지원하는 웹 어플리케이션 테스트 프레임워크
- watir: Ruby 사용

# 6. 화면 설계

## 사용자 인터페이스

- 사용자와 시스템 사이에서 의사소통할 수 있도록 고안된 물리적, 가상의 매개체
- 정보 기기나 소프트웨어의 홤녀 등에서 사람이 접하게 되는 화면

### 유형

- CLI, GUI, NUI, OUI

### 설계 원칙

- 직관성
- 유효성
- 학습성
- 유연성

### 지침

- 사용자 중심
- 일관성
- 단순성
- 결과 예측 가능
- 가시성
- 표준화
- 접근성
- 명확성
- 오류 발생 해결

### UI 품질 요구사항

- 기능성: 실제 수행 결과와 품질 요구사항의 차이를 분석하고, 실제 사용 시 정확하지 않은 결과가 발생할 확률과 관련하여 시스템의 동작을 관찰하기 위한 품질 기준
  - 상세 품질 요구사항
    - 적절성
    - 정밀성
    - 상호 운용성
    - 보안성
    - 호환성
  - 신뢰성
    - 성숙성
    - 고장 허용성
    - 회복성
  - 사용성
    - 이해성
    - 학습성
    - 운용성
  - 효율성
    - 시간 효율성
    - 자원 효율성
  - 유지보수성
    - 분석성
    - 변경성
    - 안정성
    - 시험성
  - 이식성
    - 적용성
    - 설치성
    - 대체성

### UI 표준

- 디자인 철학과 원칙 기반하에 전체 시스템에 공통으로 적용되는 화면 간 이동, 화면 구성 등에 관한 규약
- 구성
  - 전체적인 UX 원칙
  - 정책 및 철학
  - UI 스타일 가이드
  - UI 패턴 모델 정의
  - UI 표준 수립을 위한 조직 구성

### UI 개발을 위한 주요 기법

- 3C 분석: 고객, 자사의 경쟁사를 비교 분석하는 기법
- SWOT 분석
- 시나리오 플래닝: 불확실성이 높은 상황 변화를 사전에 예측하고 다양한 시나리오를 설계하는 기법
- 사용성 테스트: 사용자가 직접 제품을 사용하면서 미리 작성된 시나리오에 맞추어 과제를 수행한 수집하는 기법
- 워크숍: 소집단 정도의 인원으로 특정 문제나 괒에 대한 새로운 지식, 기술 등을 교환하고 검토하는 연구회

### UI 화면 설께 구분

- 와이어 프레임: 이해 관계자들과의 화면구성을 협의하거나 서비스의 간략한 흐름을 공유하기 위해 화면 단위의 레이아웃을 설계하는 작업
- 스토리 보드: 정책, 프로세스, 콘텐츠 구성 등 서비스 구축을 위한 모든 정보가 담겨 있는 설계 산출물
- 프로토타입: 정적인 와이어 프레임또는 스토리 보드에 동적 효과를 적용 구현된 것처럼 시뮬레이션 하는 모형

## UML(Unified Modeling Language)

- 객체 지향 소프트웨어 개발 과정에서 산출물을 명세화, 시각화, 문서화 할 때 사용되는 모델링 기술과 방법론을 통합해서 만든 표준화된 범용 모델링

### UML 특징

- 가시화 언어: 개념 모델 작성 시 오류가 적고 의사소통이 용이
- 구축 언어: 다양한 프로그래밍 언어로 실행 시스템의 예측 가능
- 명세화 언어: 정확한 모델 제시, 완전한 모델 작성 가능
- 문서화 언어: 시스템에 대한 평가 및 의사소통의 문서

### UML 구성요소

- 사물: 추상적인 개념으로 주제를 나타내는 요소
- 관계: 사물의 의미를 확장하고 명확히 하는 요소
- 다이어그램: 사물과 관계를 모아 그림으로 표현한 형태

### UML 다이어그램

- 구조적 다이어그램/정적 다이어그램
  - 클래스: 객체 지향 모델링 시 클래스의 속성 및 연산과 클래스 간 정적인 관계를 표현
  - 객체: 클래스에 속한 사물들, 즉 인스턴스를 특정 시점의 객체와 객체 사이의 관계로 표현
  - 컴포넌트: 시스템을 구성하는 물리적인 컴포넌트와 그들 사이의 의존 관계를 표현
  - 배치: 컴포넌트 사이의 종속성을 푠현하고, 물리적 요소들의 위치를 표현
  - 복합체 구조: 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현
  - 패키지: 유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계를 표현
- 행위적 다이어그램/동적 다이어그램
  - 유스케이스: 시스템이 제공하는 있는 기능 및 그와 관련된 외부 요소를 사용자의 관점에서 표현
  - 시퀀스: 객체 간 동적 상호 작용을 시간적 개념을 중점으로 메시지 흐름으로 표현
  - 커뮤니케이션: 동작에 참여하는 객체들이 주고받는 메시지를 표현하고, 객체 간의 연관도 표현
  - 상태: 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는지 표현
  - 활동: 시스템이 어떤 기능을 수행하는지를 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서대로 표현
  - 타이밍: 객체 상태 변화와 시간 제약을 명시적으로 표현

### UML 스트레오 타입

- `<<include>>`: 하나의 유스케이스가 어떤 시점에 다른 유스케이스를 실행하는 포함관계
- `<<extend>>`: 하나의 유스케이스가 어떤 시점에서 다른 유스 케이스를 실행할 수도 아닐 수도 있는 확장관계
- `<<interface>>`: 모든 메서드가 추상 메서드이며 바로 인스턴스를 만들 수 없는 클래스
- `<<entity>>`: 유스케이스 처리 흐름이 수행되는 과정에서 기억 장치에 저장되어야 할 정보를 표현하는 클래스
- `<<boundary>>`: 시스템과 외부 액터와의 상호 작용을 담당하는 클래스
- `<<control>>`: 시스템이 제공하는 기능의 로직 및 제어를 담당하는 클래스

## 클래스 다이어그램

- 객체 지향 모델링 시 클래스의 속성 및 연산과 클래스 간 정적인 관계를 표현한 다이어그램
- 구성요소
  - 클래스: 공통의 속성, 연산, 관계, 의미를 공유하는 객체들의 집합
  - 속성: 클래스의 구조적 특성
  - 연산: 클래스의 행위적 특징
  - 접근제어자: - 프라이빗, + 퍼블릭, # 프로텍티드, ~ 디폴트
- 관계
  - 연관 관계: 클래스가 서로 개념적으로 연결된 선
  - 의존 관계: 하나의 클래스가 또 다른 클래스를 사용하는 관계
  - 일반화 관계: 하나의 사물이 다른 사물에 비해 더 일반적인 구체적인지를 표현
  - 실체화 관계: 추상 클래스나 인터페이슬 상속받아 자식 클래스가 추상메서드를 구현할 때 표현
  - 포함 관계: 영구적이고 집합 관계보다 더 강한 관계로 구성
  - 집합 관계: 하나의 객체에 여러 개의 독립적인 객체들이 구성되는 단계

## 유스케이스 다이어그램

- 시스템이 제공하고 있는 기능과 그와 관련된 외부 요소를 사용자의 관점에서 표현하는 다이어그램
- 구성요소
  - 유스케이스: 시스템이 제공하는 서비스, 기능
  - 액터: 사용자가 시스템에서 수행하는 역할
  - 시스템
  - 시나리오
  - 이벤트의 흐름
- 관계
  - 포함 관계
  - 확장 관계
  - 일반화 관계

## 시퀀스 다이어그램

- 객체 간 상호 작용을 메세지 흐름으로 표현한 다이어그램
- 구성요소
  - 객체
  - 생면선
  - 실행
  - 메시지

## 패키지 다이어그램

- 시스템의 서로 다른 패키지들 사이의 의존 관계를 표현하는 다이어그램
- 구성요소
  - 패키지
  - 의존관계

## 활동 다이어그램

- 시스템이 어떤 기능을 수행하는지 객체의 처리로직이나 조건에 따른 처리의 흐름을 순서대로 표현하는 다이어그램
- 구성요소
  - 시작점
  - 전이
  - 액션/액티비티
  - 종료점
  - 조건 노드
  - 병합 노드
  - 포크 노드
  - 조인 노드
  - 구획면

## 상태 다이어그램

- 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는 표현하는 다이어그램
- 구성요소
  - 상태
  - 시작 상태
  - 종료 상태
  - 전이
  - 이벤트
  - 전이 조건

## 커뮤니케이션 다이어그램

- 동작에 참여하는 객체들이 주고받는 메시지를 표현하고, 메시지뿐 아닌 객체 간의 연관 관계도 표현하는 다이어그램
- 구성요소
  - 액터
  - 객체
  - 링크
  - 메시지

## 컴포넌트 다이어그램

- 시스템을 구성하는 물리적인 컴포넌트와 그들 사이의 의존적인 관계를 표현하는 다이어그램
- 구성요소
  - 컴포넌트
  - 인터페이스
  - 의존관계

## UI 시나리오 문서의 작성 요건

- 완전성: 시나리오는 누락이 없어야 하고, 최대한 빠짐없이 가능한 상세하게 기술
- 일관성: 서비스에 대한 목표, 시스템 및 사용자의 요구사항에 일관성이 있어야 함
- 이해성: 처음 접하는 사람도 이해하기 쉽도록 구성
- 가독성: 문서를 쉽게 읽을 수 있어야 하고, 표준화도 템플릿을 작성하여 사용
- 추적 용이성: 쉽게 추적이 가능해야 함
- 수정 용이성: 쉽게 수정이 가능해야 함

# 7. 프로그래밍 언어 활용

## 객체 지향 프로그래밍의 구성 요소

- 객체, 클래스, 메시지

## 객체의 구성 요소

- 개체, 속성, 메서드

## 라이브러리

- 필요할 때 찾아서 쓸 수 있는 모듈화되어 제공되는 프로그램
- 구성요소
  - 도움말
  - 설치 파일
  - 샘플코드

# 8. SQL 응용

## 트랜잭션

- 데이터를 보장하기 위해 DBMS가 가져야 하는 특성
- 데이터베이스 시스템에서 하나의 논리적 기능을 정상적으로 수행하기 위한 작업의 기본 단위
- 특성: ACID
  - 원자성(Atomicity): 트랜잭션의 연산은 데이터베이스에 모두 반영되도록 완료되던지 반영되지 않도록 복구 되던지 해야된다.
  - 일관성(Consistency): 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환된다.
  - 독립성(Isolation): 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우, 서로 다른 트랜잭션의 연산에 끼어들 수 없다.
  - 지속성(Durability): 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.
- 상태
  - 활동: 초기상태, 실행 중일 때
  - 부분 완료: 마지막 명령문 이후 가지는 상태
  - 완료: 트랜잭션이 성공적으로 완료된 후
  - 실패: 정상적이 더 이상 진행될 수 없을 때
  - 철회: 트랜잭션이 취소되고 시작전으로 롤백된 상태

## 병행제어

- 다수의 사용자 환경에서 여러 트랜잭션이 수행할 때, 데이터베이스 일관성 유지를 위해 상호 작용을 제어하는 기법
- 목적
  - 데이터베이스 공유 최대화
  - 시스템의 활용도 최대화
  - 데이터베이스의 일관성 유지
  - 사용자에 대한 응답시간 최소화
- 미보장시 문제점
  - 갱신 손실: 먼저 실행된 트랜잭션의 결과를 나중에 실행된 트랜잭션이 덮어쓸 때 발생
  - 현황 파악 오류: 트랜잭션의 중간 수행 결과를 다른 트랜잭션이 참조하여 발생하는 오류
  - 모순성: 데이터베이스에 일관성이 결여
  - 연쇄 복귀: 복수의 트랜잭션이 데이터 공유 시 특정 트랜잭션이 처리를 취소할 경우 트랜잭션이 처리한 곳의 부분을 취소하지 못함.
- 기법의 종류
  - 로킹: 같은 자원을 엑세스하는 다중 트랜잭션 환경에서 DB의 일관성과 무결성을 유지하기 위해 트랜잭션의 순차적 진행을 보장하는 직렬화 기법
  - 낙관적 검증: 트랜잭션 수행 후 종료 시 검증을 수행하여 데이터베이스에 반영
  - 타임 스탬프 순서: 타임스탬프를 부여하여 부여된 시간에 따라 트랜잭션 작업을 수행하는 기법
  - 다중버전 동시성 제어: 트랜잭션의 타임스탬프와 접근하려는 데이터의 타임 스탬프를 비교하여 직렬 가능성이 보장되는 적절한 버전을 선택하여 접근하도록 하는 기법

## 회복기법

- 트랜잭션을 수행하는 도중 장애로 인해 손상된 데이터베이스를 손상되기 이전의 정상적인 상태로 복구하는 기법
- 종류
  - 로그기반 회복
    - 지연 갱신 회복
    - 즉각 갱신 회복
  - 체크 포인트 회복: 검사점을 만들어 검사점 이후 처리된 트랜잭션 대해서만 회복하는 기법
  - 그림자 페이징 회복: 데이터베이스 트랜잭션 수행 시 복제본을 생성하여 이를 이용

## 옵티마이저

- 최적의 처리 경로를 생성해주는 DBMS 내부의 핵심엔진
- 유형
  - RBO: 통계 정보가 없는 상태에서 사전 등록된 규칙에 따라 질의 실행 계획을 선택하는 옵티마이저
  - CBO: 통계 정보로부터 모든 접근 경로를 고려한 질의 실행 계획을 선택하는 옵티마이저
- 역할
  - 쿼리 변환
  - 비용 산정
  - 계획 생성

## DDL

- create, alter, drop, truncate

## DCL

- grant, revoke, commit, rollback

## DML

- select, insert, update, delete

## 프로시저

- 일련의 쿼리들을 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합

## 트리거

- 데이터베이스의 이벤트를 감지하여 관련 작업이 자동으로 수행하게 하는 절차형 SQL

## 사용자 정의 함수

- 종료시 처리 결과로 단일값만을 변환하는 절차형 SQL

# 9. 소프트웨어 개발 보안 구축

## SW 개발 보안 3대 요소

- 기밀성: 인가되지 않은 개인 혹은 시스템 접근에 따른 정보 공개 및 노출을 차단하는 특성
- 무결성: 데이터의 정확성 및 완정성과 고의/악의로 변경되거나 훼손 또는 파괴되지 않음을 보장
- 가용성: 서비스를 지속해서 사용할 수 있도록 보장하는 특성

## 개발 보안 용어

- 자산
- 위협
- 취약점
- 위험

## DoS(Denial of Service) 공격

- 시스템을 악의적으로 공객해서 해당 시스템 자원을 부족하게 하여 원래 의도된 용도로 사용하지 못하게 하는 공격
- 종류
  - SYN Flooding: TCP 프로토콜의 구조적 문제를 이용한 공격
  - UPD Flooding: 대량의 패킷을 전송하여 응답메시지를 생성하게 하여 자원을 고갈
  - Smurf: 출발지 주소를 공격대상의 IP로 설정하여 네트워크 전체에게 ICMP echo 패킷을 브로드캐스팅 하여 마비시키는 공격
  - 죽음의 핑: ICMP 패킷을 정상적인 크기보다 아주 크게 만들어 전송하면 다수의 IP 단편화가 발생하고 수신 측에서는 단편화된 패킷을 처리하는 과정에서 자원이 고갈되어 정상적인 서비스를 하지 못함.
  - 랜드 어택: 출발지와 목적지가 IP 가 같은 패킷 주소를 만들어 보냄으로 수신자가 자신에게 응답을 보내게 하여 시스템의 가용성을 침해
  - 티어 드롭: IP 패킷의 재조합 과정에서 잘못됨 플레그먼드 오프셋 정보로 인해 수신 시스템에 문제를 야기하는 공격
  - 봉크: 프로토콜의 오류 제어를 이용한 공격기법

## DDos(Distributed Denial of Service) 공격

- 여러 대의 공격자를 분산 배치하여 동시에 동작함으로 특정 사이트를 공격하는 기법
- 구성요소
  - 핸들러
  - 에이전트
  - 마스터
  - 공격자
  - 데몬 프로그램

## 인증 기술의 유형

- 지식 기반 인증
- 소지 기반 인증
- 생체 기반 인증
- 특징 기반 인증

## 서버 접근 통제 유형

- 임의적 접근 통제(DAC): 주체나 그룹의 신분에 근거하여 객체에 대한 접근을 제한
- 강제적 접근 통제(MAC): 객체에 포함된 정보의 허용등급과 주체가 갖는 접근 허가 권한에 근거하여 제한
- 역할 기반 접근 통제(RBAC): 중앙 관리자가 사용자와 시스템의 상호관계를 통제하여 조직 내 맡은 역할에 기초하여 자원에 대한 접근 통제

## 3A

- 인증, 권한 부여, 계정관리

## 벨-라파듈라 모델(BLP)

- 미 국방부 지원 보안 모델로 보안 요소 중 기밀성을 강조하며 강제적 정책에 의해 접근 통제하는 모델
- No Read Up, No Written Down

## 비바 모델

- 벨-라파듈라 모델의 단점을 보완한 무결성을 지원하는 모델

## 대칭 키 암호화 알고리즘

- DES
- SEED
- AES
- ARIA
- IDEA
- LFSR

## 비대칭 키 암호화 알고리즘

- 디피 헬만
- RSA
- ECC
- EIGamal

## 해시 알고리즘

- MD5
- SHA-1
- SHA-256/384/512
- HAS-160
- HAVAL

## 시큐어 코딩 가이드 적용 대상

- 입렵 데이터 검증 표현
- 시간 및 상태
- 보안 기능
- 에러 처리
- 코드 오류
- 캡슐화
- API 오용

## XSS

- 검증되지 않은 외부 입력 데이터가 포함된 웹페이지가 전송되는 경우 사용자가 해당 페이지를 열람함으로써 웹페이지에 포함된 부적절한 실행되는 공격
- 유형
  - Stored
  - Reflected
  - DOM

## CSRF

- 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위를 특정 웹사이트에 요청하게 하는 공격

## SQL 삽입

- 응용 프로그램의 보안 취약점을 이용해서 악의적인 SQL 구문을 삽입, 실행 시켜서 데이터베이스의 접근을 통해 정보를 탈취하거나 조작 등의 행위를 하는 공격 기법
- FROM
- Union
- Stored Procedure
- Mass
- Error-Based
- Blind

## 네트워크 보안 솔루션

- 방화벽
- 웹 방화벽
- 네트워크 접근 제어
- 침입 탐지 시스템
- 침입 방지 시스템
- 무선 침입 방지 시스템
- 통합 보안 시스템

## DRS(Disaster Recovery System)

- 재해복구계획의 원할 수행을 지원하기 위해 평상시 확보해두는 인적, 물적 자원 및 이들에 대한 지속적인 관리체계가 통합된 재해복구센터

## 허니팟

- 비정상적인 접근을 탐지하기 위해 의도적으로 설치해 둔 시스템
- 일부러 허술하게 만들어 해커에게 노출하는 유인시스템

# 10. 어플리케이션 테스트 관리

## 소프트웨어 테스트 필요성

- 오류 발견 관점: 잠재된 오류를 발견하고 수정하여 올바른 프로그램을 개발하기 위해 필요
- 오류 예방 관점: 오류를 사전에 발견하는 예방 차원의 필요
- 품질 향상 관점: 제품의 신뢰도를 향상하는 품질 보증을 위해 필요

## 소프트웨어 테스트 기본 원칙

- 결함 존재 증명
- 완벽 테스트 불가능
- 초기에 테스트 시작
- 결합 집중: 파레토의 법칙
- 살충제 페러독스: 동일한 테스트 케이스에 의한 반복적 테스틑 버그를 찾지 못함
- 정황에 의존
- 오류-부재의 궤변: 요구사항을 충족시키지 못한다면 결함이 없다고 해도 품질이 높다고 할 수 없다.

## 화이트박스 테스트

- 각 응용 프로그램의 내부 구조와 동작을 검사하는 소프트웨어 테스트
- 유형
  - 구문 커버리지: 모든 명령문을 적어도 한 번 수행
  - 결정 커버리지: 전체 조건식이 적어도 한번은 참 거짓 결과를 수행
  - 조건 커버리지: 각 조건식이 적어도 한번은 참 거짓 결과가 되도록 수행
  - 조건/결정 커버리지: 전체 조건식, 개별 조건식이 한번은 참 거짓 결과 되도록 수행
  - 변경 조건/결정 커버리지:
  - 다중 조건 커버리지: 결정 조건 내 모든 개별 조건식의 모든 가능한 조합을 100% 보장
  - 기본 경로 커버리지: 수행 가능한 모든 경로 테스트
  - 제어 흐름 테스트: 프로그램 제어 구조를 그래프 형태로 나타내어 내부 로직을 테스트
  - 데이터 흐름 테스트: 제어 프름 그래프에 데이터 사용 현황을 추가한 그래프 통해 테스트

## 블랙박스 테스트

- 프로그램 외부 사용자의 요구사항 명세를 보면서 수행하는 테스트
- 유형
  - 동등분할 테스트: 입력 데이터 영역을 도메인별로 유효값/무효값을 그룹핑하여 대표값 테스트 케이스 도출
  - 경계값 분석 테스트: 등가 분할 후 경계값 부분에서 오류 발생 확률이 높기 때문에 경계값을 포함하여 테스트 케이스를 설계
  - 결정 테이블 테스트: 요구사항의 논리와 발생조건을 테이블형태로 나열하여 조건과 행위를 모두 조합하여 테스트
  - 상태 전이 테스트: 객체의 상태를 구분하고 이벤트에 의해 어느 한 상태에서 다른 상태로 전이되는 경우의 수를 수행
  - 유스케이스 테스트: 시스템이 실제 사용되는 유스케이스로 모델링되어 있을 때 프로세스 흐름을 기반으로 테스트케이스를 명세화하여 수행
  - 분류 트리 테스트: SW의 일부 또는 전체를 트리 구조로 분석 및 표현하여 테스트 케이스를 설계
  - 페어와이즈 테스트: 테스트 데이터값들 간에 최소한 한 번씩을 조합하는 방식
  - 원인-결과 테스트: 그래프를 활용하여 입력데이터 간의 관계 및 출력에 미치는 영향을 분석하여 효용성이 높은 테스트 케이스를 선정하여 테스트
  - 비교 테스트: 여러 버저느이 프로그램에 같은 입력값을 넣어서 동일한 결과가 나오는지 테스트

## 테스트 목적에 따른 분류

- 회복 테스트: 실패 유도 후 시스템의 정상적 복귀 여부 테스트
- 안전 테스트: 소스 코드 내의 보안적 결함을 미리 점검
- 성능 테스트: 사용자의 이벤트에 시스템이 응답하는 시간 등 반응 속도 측정
- 구조 테스트: 시스템의 내부 논리 경로, 소스 코드의 복잡도를 평가
- 회귀 테스트: 오류를 제거하거나 수정한 시스템에서 부수효과가 없는지 확인하는 반복 테스트
- 병행 테스트: 변경된 시스템과 기존 시스템에 동일한 데이터를 입력 후 결과 비교

## 성능 테스트의 성능유형

- 부하 테스트: 시스템의 부하를 계속 증가시키며 임계점을 찾는 테스트
- 강도 테스트: 임계점 이상의 부하를 가하며 비정상적인 상황에서의 처리를 테스트
- 스파이크 테스트: 짧은 시간에 사용자가 몰릴 때 시스템 반응 측정 테스트
- 내구성 테스트: 오랜 시간 동안 시스템에 높은 부하를 가하여 시스템 반응 테스트

## 테스트 종류에 따른 분류

- 명세 기반 테스트: 프로그램의 요구사항 명세러를 기반으로 테스트 케이스를 선정하여 테스트
- 구조 기반 테스트: 소프트웨어 내부 논리 흐름을 따라 테스트 케이스를 작성하고 확인
- 경험 기반 테스트: 테스터의 경험을 토대로 한, 작관과 기술 능력을 기반으로 수행하는 테스트

## 테스트 커버러지

- 프로그램의 테스트 수행 정도를 나타내는 값
- 유형
  - 기능 기반 커버리지: 전체 기능을 모수로 설정하고, 실제 테스트가 수행된 기능의 수를 측정
  - 라인 기반 커버리지: 전체 코드 라인 수를 모수로 테스트 시나리오가 수행한 코드 라인 수 측정
  - 코드 커버리지: 소스 코드의 구문, 조건, 결정 등의 구조 코드 자체가 얼마나 실행되었는지 측정

## 테스트 오라클

- 테스트 결과가 참인지 거짓인지 판단하기 위해 사전에 정의된 참 값을 입력하여 비교
- 종류
  - 참 오라클: 모든 입력값에 대하여 기대하는 결과를 생성함으로서 발생된 오류를 모두 검출
  - 샘플링 오라클: 특정한 몇 개의 입력값에 대해서만 기대하는 결과 제공
  - 휴리스틱 오라클: 특정 입력값에 대해 올바른 결과를 제공하고 나머지 값들에 대해서는 휴리스틱으로 처리
  - 일관성 검사 오라클: 어플리케이션에 변경이 있을 때 수행 전 과 수행 후의 결과값이 동일한지 비교

## 테스트 레벨

- 함께 편성되고 관리되는 테스트 활동의 그룹
- 유형

  - 단위
  - 통합
  - 시스템
  - 인수

## 하향식 및 상향식 통합 수행 방식

- 하향식 스텁, 상향식 드라이버

## 테스트 하네스 구성요소

- 드라이버
- 스텁
- 슈트
- 케이스
- 시나리오
- 스크립트
- 목 오브젝트

## 결합 심각도별 분류

- 치명적
- 주요
- 보통
- 경미한
- 단순

# 11. 응용 SW 기초 기술

## 어플리케이션 성능 지표

- 처리량
- 응답 시간
- 경과 시간
- 자원 사용률

## 데이터베이스 성능저하 원인

- DB Lock
- DB Fetch
- Connection Leak
- Pool size
- commit

## 배드 코드 유형

- 오염
- 문서 부족
- 의미 없는 이름
- 높은 결함도
- 아키테처 침식

## 클린코드

- 가독성
- 단순성
- 의존성 최소
- 중복성 제거
- 추상화

## 메모리 관리 기법

- 반입기법
- 배치기법
- 할당기법
- 교체기법

## 배치기법의 유형

- 최초 적합
- 최적 적합
- 최악 적합

## 프로세스 상태

- 생성 상태
- 준비 상태
- 실행 상태
- 대기 상태
- 완료 상태

## 프로세스 상태 전이

- 디스패치
- 타이머 런 아웃
- 블록
- 웨이크업

## 선점 스케줄링 알고리즘

- SRT
- MLQ
- MLFQ
- Round Robin

## 비선점형 스케줄링 알고리즘

- 우선순위
- 기한부
- HRN
- FCFS
- SJF

## 교착상태 발생조건

- 상호배제
- 점유와 대기
- 비선점
- 환형 대기

## 교착상태 해결 방법

- 예방
- 회피
- 발견
- 복구

## 클라우드 컴퓨팅 분류

- 사설
- 공용
- 하이브리드

## 클라우드 서비스 유형

- 인프라형
- 플래폼형
- 소프트웨어형

## 프로토콜 기본 3요소

- 구문: 전송하고자 하는 데이터의 형식
- 의미: 두 기기 간의 효율적이고 정확한 정보 전송을 위한 협조사항과 제어 정보 규정
- 타이밍: 두 기기간의 통신 속도

## IPv4 전송

- 유니캐스트
- 멀티캐스트
- 브로드 캐스트

## TCP 특징

- 신뢰성 보장
- 연결 지향적 특징
- 흐름 제어
- 혼잡 제어

# 12. 제품소프트웨어 패키징

## 패키징 도구 구성요소

- 암호화
- 키 관리
- 식별 기술
- 저작권 표현
- 암호화 파일 생성
- 정채 관리
- 크랙 방지
- 인증

<hr/>

_개인이 참고하고자 작성한 글이며, 잘못된 정보가 있을 수 있습니다. 잘못된 정보는 메일로 보내주시면 감사하겠습니다._ 🙏
