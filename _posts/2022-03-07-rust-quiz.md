---
title: "Rust - chapter 8 quiz"
date: 2022-03-07
comments: true
read_time: false
toc: true
categories:
  - Rust
tags:
  - rust
  - collection
  - quiz
---

8 ì±•í„° ë§ˆì§€ë§‰ ì •ë¦¬ì— í€´ì¦ˆê°€ ìˆì—ˆë‹¤. ì‰½ê² ê±°ë‹ˆ í–ˆëŠ”ë° ë‚˜í•œí…ŒëŠ” ìƒê°ë³´ë‹¤ ì–´ë ¤ì› ë‹¤. ğŸ¥¶  
í’€ê¸°ëŠ” ì§€ë‚œì£¼ì— í’€ì—ˆëŠ”ë° ì •ë¦¬ì°¨ ì˜¬ë ¤ë³¸ë‹¤. ë§í¬ ìµœí•˜ë‹¨ì—ì„œ í™•ì¸ì´ ê°€ëŠ¥í•˜ë‹¤.  
`&`, `*` ë¡œ ê·¸ë¦¬ê³  `ì†Œìœ ê¶Œ` ë“± í‰ì†Œ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ê°œë…ì´ë‹¤ ë³´ë‹ˆ í™•ì‹¤íˆ ë‚¯ì„¤ì—ˆë‹¤.

ë¶ˆê³¼ ì§€ë‚œì£¼ì— ì‘ì„±í•œ ê±´ë° ì •ë¦¬í•˜ë©´ì„œ ë‹¤ì‹œë³´ë‹ˆ ë†“ì¹œë¶€ë¶„ì´ë‚˜ ê³ ì¹  ë¶€ë¶„ì´ ë³´ì¸ë‹¤. ì–¼ë§ˆë‚˜ ëŒ€ì¶© ì‘ì„±í–ˆë˜ ê±°ì•¼... ğŸ’©

> ì½”ë“œê°€ ì´ìƒí•´ë„.. ë´ì£¼ì‹­ì…”. ë¬¸ì œë˜ëŠ” ë¶€ë¶„ì´ë‚˜ ê°œì„ ì ì€ ë©”ì¼ë¡œ ë³´ë‚´ì£¼ì‹œë©´ ì •ë§ ê°ì‚¬ë“œë¦¬ê² ìŠµë‹ˆë‹¤!

[ì›ë¬¸ë§í¬](https://rinthel.github.io/rust-lang-book-ko/ch08-03-hash-maps.html)

## í€´ì¦ˆ 1

### ì •ìˆ˜ë¦¬ìŠ¤íŠ¸ê°€ ì£¼ì–´ì¡Œì„ ë•Œ í‰ê· ê°’, ì¤‘ê°„ê°’, ìµœë¹ˆê°’ì„ êµ¬í•˜ë¼.

ì…ë ¥ìœ¼ë¡œ ë°›ì•„ì„œ í• ê¹Œ í•˜ë‹¤ê°€ ì½”ë“œ ë‚´ì— ì§ì ‘ ë„£ì–´ì„œ ì‘ì—…í•˜ì˜€ë‹¤.  
í•˜ëŠ” ê¹€ì— ìµœëŒ€ê°’, ìµœì†Ÿê°’ë„ ì¶”ê°€í•˜ì˜€ë‹¤.

```rs
use std::collections::HashMap;

fn main() {
   let temp_integers = vec![1,2,3,4,5,5,6,6,7,8,9,10];

    println!("Max: {}", match max(&temp_integers) {
        Some(max) => max.to_string(),
        None => "Vector is empty".to_string(),
    });

    println!("Min: {}", match min(&temp_integers) {
        Some(min) => min.to_string(),
        None => "Vector is empty".to_string(),
    });

    println!("Mean: {}", match mean(&temp_integers) {
        Some(mean) => mean.to_string(),
        None => "Vector is empty".to_string(),
    });

    println!("Median: {}", match median(&temp_integers) {
        Some(median) => median.to_string(),
        None => "Vector is empty".to_string(),
    });

    mode(&temp_integers);
}

fn max(temp_vec: &Vec<i32>) -> Option<i32> {
    let mut max = None;
    for i in temp_vec {
        if max.is_none() {
            max = Some(*i);
        } else {
            if *i > max.unwrap() {
                max = Some(*i);
            }
        }
    }
    max
}

fn min(temp_vec: &Vec<i32>) -> Option<i32> {
    let mut min = None;
    for i in temp_vec {
        if min.is_none() {
            min = Some(*i);
        } else {
            if *i < min.unwrap() {
                min = Some(*i);
            }
        }
    }
    min
}

fn mean(temp_vec: &Vec<i32>) -> Option<f32> {
    if temp_vec.len() == 0 {
        return None;
    }

    let mut sum = 0.0;
    for i in temp_vec {
        sum += *i as f32;
    }

    Some(sum / temp_vec.len() as f32)
}

fn median(temp_vec: &Vec<i32>) -> Option<i32> {
    if temp_vec.len() == 0 {
        return None;
    }

    let mut cloned_vec = temp_vec.clone();
    cloned_vec.sort();

    Some(cloned_vec[cloned_vec.len() / 2])
}

fn mode(temp_vec: &Vec<i32>) {
    if temp_vec.len() == 0 {
        println!("Vector is empty");
        return;
    }

    let mut map: HashMap<i32, i32> = HashMap::new();
    let mut max_count = 0;

    for i in temp_vec {
        let count = map.entry(*i).or_insert(0);
        *count += 1;
        if *count > max_count {
            max_count = *count;
        }
    }

    let mut result = map.iter().filter(|&(_, v)| v == &max_count).map(|(k, _)| k).collect::<Vec<&i32>>();
    result.sort();

    println!("Mode: {:?}", result);
}
```

## í€´ì¦ˆ 2

### ìŠ¤íŠ¸ë§ì„ í”¼ê·¸ ë¼í‹´ìœ¼ë¡œ ë³€ê²½í•˜ë¼.

ì²« ììŒì„ ë”°ì„œ ë‹¨ì–´ ë’¤ì— `-${ì²«ììŒ}ay` ì´ëŸ°ì‹ì˜ ë¬¸ìì—´ì„ ë¶™ì—¬ì„œ ë¦¬í„´í•˜ê³  ì²«ê¸€ìê°€ ëª¨ìŒì¼ ê²½ìš°ì—ëŠ” `-hay` ë¥¼ ë¶™ì—¬ ë¦¬í„´í•˜ëŠ” í”„ë¡œê·¸ë¨ì´ë‹¤.  
~~rust ì— ? : í˜•íƒœì˜ ì‚¼í•­ì—°ì‚°ìëŠ” ì—†ëŠ” ê²ƒ ê°™ë‹¤. ëª» ì°¾ì•˜ë‹¤.~~

```rs
fn main() {
    const VOWELS: &str = "aeiou";
    println!("Enter a word for Pig-Latin(Only English): ");
    let mut input_text = String::new();
    std::io::stdin().read_line(&mut input_text).expect("Failed to read line");

    if input_text.trim().is_empty() {
        println!("Input is empty");
        return;
    }

    let mut result = String::new();
    let input_text_length = input_text.len();
    let start_char = &input_text[0..1];

    result = if VOWELS.contains(start_char) { format!("{}-hay", input_text.trim()) }
        else { format!("{}-{}ay", &input_text[1..].trim(), start_char) };

    println!("Pig Latin: {}", result);
}
```

## í€´ì¦ˆ 3

### íšŒì‚¬ ë‚´ ë¶€ì„œì— ì‚¬ëŒì„ ì¶”ê°€í•˜ê³  í™•ì¸ í•  ìˆ˜ ìˆëŠ” í…ìŠ¤íŠ¸ ì¸í„°í˜ì´ìŠ¤ë¥¼ ë§Œë“¤ì–´ë¼.

ì˜ˆì œì— ì£¼ì–´ì§„ í˜•íƒœë¡œ ëª…ë ¹ë¬¸ì„ ë§Œë“¤ì–´ì„œ ì‘ì—…í•˜ì˜€ë‹¤.  
ì‚­ì œí•˜ëŠ” ëª…ë ¹ ì¶”ê°€ ì‘ì—…í•˜ì˜€ë‹¤. ì½”ë“œë¥¼ ë³´ë©´ ì–´ì§ˆì–´ì§ˆí•œë° ë­”ê°€ ìƒê°ë‚˜ëŠ” ë°©ë²•ì´ ì—†ì–´ì„œ ì¼ë‹¨ ì—¬ê¸°ê¹Œì§€ë§Œ ì‘ì—…í•˜ì˜€ë‹¤.

```rs
use std::collections::HashMap;

fn main() {
    print_manual();

    let mut company_db: HashMap<String, Vec<String>> = HashMap::new();

    loop {
        let mut command = String::new();

        println!("Enter your command: ");
        std::io::stdin().read_line(&mut command).expect("Failed to read line");
        if command.trim() == "Exit" {
            break;
        }
        if command.trim() == "Show all" {
            println!("{:?}", company_db);
        } else {
            let command_split: Vec<&str> = command.split(" ").collect();
            let command_type = command_split[0];

            if command_type == "Add" {
                let command_name = command_split[1];
                let command_department = command_split[3].trim();
                let mut employees = company_db.entry(command_department.to_string()).or_insert(Vec::new());
                employees.push(command_name.to_string());
            } else if command_type == "Remove" {
                let command_name = command_split[1];
                let command_department = command_split[3].trim();
                let mut employees = company_db.entry(command_department.to_string()).or_insert(Vec::new());
                employees.retain(|x| x != command_name);
            } else if command_type == "Show" {
                let command_department = command_split[1].trim();
                let employees = company_db.get(command_department);
                if employees.is_some() {
                    println!("{:?}", employees.unwrap());
                } else {
                    println!("No employees in this department");
                }
            } else {
                println!("Invalid command");
            }
        }
    }
}

fn print_manual() {
    println!("> Company data text editor is running!!!!");
    println!("> Use 'Add {{employee_name}} to {{department_name}}' to insert");
    println!("> Use 'Remove {{employee_name}} to {{department_name}}' to delete");
    println!("> Use 'Show {{department_name}}' to select specific department");
    println!("> Use 'Show all' to select all");
    println!("> Use 'Exit' to quit this program");
}
```

<hr/>

_ê°œì¸ì´ ì°¸ê³ í•˜ê³ ì ì‘ì„±í•œ ê¸€ì´ë©°, ì˜ëª»ëœ ì •ë³´ê°€ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ëª»ëœ ì •ë³´ëŠ” ë©”ì¼ë¡œ ë³´ë‚´ì£¼ì‹œë©´ ê°ì‚¬í•˜ê² ìŠµë‹ˆë‹¤._ ğŸ™
