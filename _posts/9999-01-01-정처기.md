# 원문, 출처 : [별의 블로그](https://starrykss.tistory.com/1856)


# 1. 요구사항 확인

## 소프트웨어 생명주기 모델
- 소프트웨어 생명주기: 시스템의 요구분석부터 유지보수까지 전 공정을 체계화한 절차
- 시스템이 개발될 때부터 운용과 유지보수를 거쳐 생애를 마칠 때까지 어떠한 순서를 밟는지에 대한 작업 프로세스를 모델화 한 것
- 프로세스 
  - 요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수 
- 모델 종류
  - 폭포수 모델: 각 단계를 확실히 마무리 지은 후 다음 단계로 넘어가는 모델
    - 타당성 검토 -> 계획 -> 요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수 
  - 프로토타이핑 모델: 고객이 요구한 주요기능을 프로토타입을 구현 후 피드백을 반영하며 만들어가는 모델
  - 나선형 모델: 시스템 개발 시 위험을 취소화하기 위해 점진적으로 완벽한 시스템으로 개발하는 모델
    - 계획 및 정의 -> 위험 분석 -> 개발 -> 고객 평가
  - 반복적 모델: 구축 대상을 나누어 병렬적으로 개발 후 통합하거나, 반복적으로 개발하여 점진적으로 완성시키는 모델

## 소프트웨어 개발 방법론
- 소프트웨어 개발 전 과정에 지속적으로 적용할 수 방법, 절차, 기법
  - 구조적 방법론: 전체 시스템을 기능에 따라 나누어 개발, 이를 통합하는 분할과 정복 접근 방식의 방법론
  - 정보공학 방법론: 정보 시스템 개발에 필요한 관리 절차와 작업 기법을 체계화한 방법론
  - 객체 지향 방법론: '객체'라는 기본 단위로 시스템을 분석 및 설계하는 방법론
  - 컴포넌트 기반 방법론: 소프트웨어를 구성하는 컴포넌트를 조립해서 하나의 새로운 응용 프로그램을 작성하는 방법론
  - 애자일 방법론: 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적용하며, 효율적으로 개발할 수 있는 **신속 적응적 경량 개발 방법론**
  - 제품 계열 방법론: 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론

## 애자일 방법론 기법
- XP(extreme Programming): 의사소통 개선과 즉각적 피드백으로 소프트웨어 품질을 높이기 위한 방법론
  - 5가지 가치
    - 용기, 단순성, 의사소통, 존중, 피드백
  - 12가지 원리
    - 짝 프로그래밍
    - 공동 코드 소유
    - 지속적인 통합
    - 계획 세우기
    - 작은 릴리즈
    - 메타포어 
    - 간단한 디자인
    - 테스트 기반 개발
    - 리팩토링
    - 40시간 작업
    - 고객 상주
    - 코드 표준
- 스크럼: 매일 정해진 시간, 장소에서 짧은 시간의 개발을 하는 팀을 위한 프로젝트 관리 중심 방법론
  - 백로그: 제품과 프로젝트에 대한 요구사항
  - 스프린트: 2~4주의 짧은 개발 기간의 반복적 수행으로 개발품질 향상
  - 스크럼 미팅: 매일 15분 정도 미팅으로 To-Do list 계획 수립
  - 스크럼 마스터: 프로젝트 리더, 스크럼 수행 시 문제 인지 및 해결하는 사람
  - 스프린트 회고: 스프린트 주기를 되돌아보며 정해놓은 규칙 준수 엽, 개선점 등을 확인 및 기록
  - 번 다운 차트: 남아있는 백로그 대비 시간을 시각적으로 표현한 차트
- 린: 도요타의 린 시스템 품질기법을 소프트웨어 개발 프로세스에 적용해서 낭비 요소를 제거하여 품질을 향상시킨 방법
  - JIT, 칸반 보드 사용 
  - 7가지 원칙
    - 낭비 제거
    - 품질 내재화 
    - 지식 창출 
    - 늦은 확정 
    - 빠른 인도
    - 사람 존중 
    - 전체 최적화

## 객체 지향 분석
- 사용자의 요구사항을 분석하여 요구된 문제와 관련된 모든 클래스, 속성, 연산, 관계를 정의하여 모델링하는 기법
- 종류
  - OOSE: 야콥슨, 유스케이스에 의한 접근 방법으로 유스케이스를 모든 모델의 근간으로 활용하는 방법론, 야콥슨
  - OMT: 럼바우, 그래픽 표기법을 이용하여 소프트웨어 구성요소를 모델링하는 방법론
    - 객체 모델링: 객체 다이어그램 활용
    - 동적 모델링: 시간의 흐름에 따라 객체들 사이의 제어 흐름, 동작 순서 등의 동적인 행위를 표현, 상태 다이어그램
    - 기능 모델링: 프로세스의 자료 흐름을 중심으로 처리 과정 표현, 자료 흐름도 활용
  - OOD: 부치, 설계 문서화를 강조하여 다이어그램 중심으로 개발하는 방법론

## 비용 산정 모형
- 소프트웨어 규모 파악을 통한 투입자원, 소요시간을 파악하여 실행 가능한 계획을 수립하기 위해 비용을 산정하는 방식
- 하향식 산정 방법
  - 전문가 판단
  - 델파이 기법
- 상향식 산정 방법
  - 코드 라인 수(LoC): 소프트웨어 각 기능의 원시 코드 라인 수의 낙관치, 중간치, 비관치를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 방식
  - Man Month: 한 사람이 1개월 동안 할 수 있는 일의 양을 기준으로 프로젝트 비용을 산정하는 방식
  - COCOMO 모형: 보헴, 비용산정 결과는 프로젝트를 완성하는 데 필요한 노력으로 산정
    - 조직형: 5만 라인 이하 
    - 반 분리형: 30만 라인 이하 
    - 임베디드형: 30만 라인 초과 
  - Putnam 모형: 생명주기 예측 모형, 각 단계별로 요구할 인력의 분포를 가정하는 방식
  - FP 모형: 요구 기능을 증가시키는 인자별로 가중치를 부여하고, 요인별 가중치를 합산하여 총 기능의 점수를 계산하여 비용을 산정하는 방식

## 일정 관리 모델
- 프로젝트가 일정 기한 내에 적절하게 완료도리 수 있도록 관리하는 모델
- 주 공정법(CPM): 여러가지 수행 순서가 얽혀 있는 프로젝트의 일정을 계산하는 방법, 가장 긴 시간이 걸리는 경로를 계산한다.
- PERT(Program Evaluation and Review Technique): 일의 순서를 계획적으로 정리하기 위한 수렴 기법 3점 추정방식을 통해 일정을 관리하는 기법
- 중요 연쇄 프로젝트 관리(CCPM): 주 공정 연쇄법으로 자원 제약 사항을 고려하여 일정을 작성하는 기법

## 소프트웨어 아키텍쳐 4+1뷰
- 고객의 요구사항을 정리해 놓은 시나리오를 4개의 관점에서 바라보는 소프트웨어적인 접근 방식
- 체크 방법으로 유스케이스를 사용한다.
  - 유스케이스: 시스템이 엑터에게 제공해야 하는 기능으로서 시스템의 요구사항이자, 사용자 입장에서 바라본 시스템의 기능 
- 1(유스케이스 뷰) + 4(논리 뷰, 프로세스 뷰, 구현 뷰, 배포 뷰)
- 유스케이스 뷰: 유스케이스 또는 아키텍처를 도출하고 설계하며 다른 뷰를 검증하는데 사용되는 뷰
  - 사용자/설계자/개발자/테스트 관점 
- 논리 뷰: 시스템의 기능적인 요구사항이 어떻게 제공되는지 설명해주는 뷰
  - 설계자/개발자 관점
- 프로세스 뷰: 시스템의 비기능적인 속성으로서 자원의 효율적인 사용, 병행 실행, 비동기, 이벤트 처리 등을 표현한 뷰
  - 개발자/시스템 통합자 관점
- 구현 뷰: 개발 환경 안에서 정적인 소프트웨어 모듈의 구성을 보여주는 뷰
- 배포 뷰: 컴포넌트가 물리적인 아키텍처에 어떻게 배치되는가를 매핑해주는 뷰

## 소프트웨어 아키텍처 패턴
- 소프트웨어를 설계할 때 참조할 수 있는 전형적인 해결 방식
- 계층화 패턴: 시스템을 계층으로 구분하여 구성하는 패턴
- 클라이언트-서버 패턴: 하나의 서버와 다수의 클라이언트로 구성된 패턴
- 파이프-필터 패턴: 데이터 스트림을 생성하고 처리하는 시스템에서 사용 가능한 패턴
- 브로커 패턴: 분리된 컴포넌트들로 이루어진 분산 시스템에서 사용되고, 이 컴포넌트들은 원격 서비스 실행을 통해 상호 작용이 가능한 패턴
- 모델-뷰-컨트롤러 패턴: 대화형 어플리케이션을 모델, 뷰, 컨트롤러의 3개의 서비 시스템으로 구조화하는 패턴

## 소프트웨어 아키텍처 비용 평가 모델
- 아키텍처 접근벙이 품질 속성에 미치는 영향을 판단하고 아키텍처의 적합성을 평가하는 모델
- SACAA
  - SAAM: 변경 용이성과 기능성에 집중, 평가가 용이하며 경험이 없는 조직에서도 활용 가능한 비용 평가 모델
  - ATAM: 아키텍처 품질 속성을 만족시키는지 판단 및 품질 속성들의 이해 상충관계가지 평가하는 모델
  - CBAM: ATAM 바탕의 시스템 아키텍처 분석 중심으로 경제적 의사결정에 대한 요구를 충족하는 비용 평가 모델
  - ADR: 소프트웨어 아키텍처 구성요소 간 응집도를 평가하는 모델
  - ARID: 전체 아키첵처가 아닌 특정 부분에 대한 품질요소에 집중하는 비용 평가 모델

## 디자인 패턴
- 소프트웨어 공학의 스프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 패턴
- 디자인 패턴의 구성요소 
  - 패턴의 이름
  - 문제 및 배경
  - 솔루션
  - 사례
  - 결과 
  - 샘플코드
- 디자인 패턴 유형
  - 목적에 따른 구분: 생성, 구조, 행위
  - 범위에 따른 구분: 클래스, 객체
  - 생성 패턴: 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행하는 패턴
    - Builder: 복잡한 인스턴스를 조립하여 만드는 구조
    - Prototype: 처음부터 일반적인 원형을 만들어 놓고, 그것을 복사한 후 필요한 부분만 수정하여 사용하는 패턴
    - Factory Method: 상위 클래스에서 객체를 생헝하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 하는 방식
    - Abstract Factory: 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴
    - Singleton: 전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객첼르 어디에서든지 참조할 수 있도록 하는 패턴
  - 구조 패턴: 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴
    - Bridge: 기능의 클래스 계층과 구현의 클래스 계층을 연결하고, 구현부에서 추상 계층을 분리하여 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있는 패턴
    - Decorator: 기존에 구현되어 있는 클래스에 필요한 기능을 추가해 나가는 패턴
    - Facade: 단순한 인터페이스를 제공함으로서, 노드 간 결합도를 낮추어 시스템 구조에 대한 파악을 쉽게 하는 패턴
    - Flyweight: 클래스 경량화를 목적으로 하는 패턴, 여러 개의 가상 인스턴스를 제공하여 메모리를 절감
    - Proxy: 실제 객체에 대한 대리 객체, 실제 객체 접근 이전에 필요한 행동을 할 수 있음. 정보 은닉의 역할도 수행하는 패턴
    - Composite: 객체들의 관계를 트리 구조로 구성하여, 부분-전체 계층을 표현하는 패턴
    - Adapter: 기존에 생성된 클래스를 재사용 할 수 있도록 중간에서 맞춰주는 역할을 하는 인터페이스를 만드는 패턴
  - 행위 패턴: 클래스나 객체들이 상호 작용하는 방법과 역할 분담을 다루는 패턴
    - Mediator: 중재자를 두고, 중재자에게 모든 것을 요구하여 통신의 빈도수를 줄여 객체 지향의 목표를 달성하는 패턴
    - Interpreter: 구체적으로 구문을 나누고 그 분리된 구문의 해석을 맡는 클래스를 작성하여 여러 형태의 구문을 해석할 수 있게 하는 패턴
    - Iterator: 컬렉션의 구현 방법을 노출시키지 않으면서 안에 들어있는 모든 항목에 접근할 방법을 제공하는 디자인 패턴
    - Template Method: 작업의 일부분을 서브 클래스로 캡슐화 하여 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴
    - Observer: 일대 다의 의존성을 가지며, 상호 작용을 하는 객체 사이에서는 가능하면 느슨하게 결합하는 패턴
    - State: 객체 상태를 캡슐화하여 클래스화 함.
    - Visitor: 각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도의 클래스를 만들고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 하는 패턴
    - Command: 각 명령이 들어오면 그에 맞는 서브 클래스가 선택되어 실행되는 특징을 갖는 패턴
    - Strategy: 알고리즘 군을 정의하고, 같은 알고리즘을 각각의 클래스로 캡슐화한 다음, 필요할 때 서로 교환해서 사용할 수 있게 하는 패턴
    - Memento: 클래스 설계 관점에서 객체의 정보를 저장할 필요가 있을 때 적용하는 패턴
    - Chain of Responsibility: 연결되어 있는 경우에 따라 동적으로 다르게 처리될 수 있도록 연결한 패턴

## 분석 산출물의 종류
- 정보 시스템 구성 현황
- 정보 시스템 기능 구성도
- 인터페이스 현황
- 현행 시스템 아키텍처 구성도
- 소프트웨어 구성도
- 하드웨어 구성도
- 네트워크 구성도

## OS 
- 컴퓨터 시스템이 제공하는 모든 하드웨어, 소프트웨어를 사용할 수 있게 해주고, 사용자와 하드웨어 간의 인터페이스를 담당하는 프로그램
- 신뢰도, 성능, 기술지원, 주변기기, 구축비용

## OSI 7계층
- 물리 계층: 0, 1 비트 정보를 회선에서 보내기 위한 전기적 신호 변환
  - 프로토콜: RS-232C
  - 전송단위: 비트
- 데이터 링크 계층: 데이터 전송 제어
  - 프로토콜: 이더넷
  - 전송단위: 프레임
- 네트워크 계층: 단말 간 데이터 전송의 최적 경로를 제공
  - 프로토콜: IP, ICMP
  - 전송단위: 패킷
- 전송 계층: 신뢰성 있는 통신 보장, 데이터 분할과 재조립, 흐름, 오류, 혼잡 제어
  - 프로토콜: TCP, UDP
  - 전송단위: 세그먼트
- 세션 계층: 연결 접속 및 동기 제어
  - 프로토콜: SSH, TLS
  - 전송단위: 데이터 
- 표현 계층: 데이터 형식 설정과 부호 교환, 암/복호화
  - 프로토콜: JPEG, MPEG
  - 전송단위: 데이터
- 응용 계층: 사용자와 네트워크 간 응용서비스 연결
  - 프로토콜: FTP, SMTP, HTTP, HTTPS
  - 전송단위: 데이터

## DBMS 현행 시스템 분석 시 고려사항
- 가용성
- 성능
- 상호 호환성
- 기술지원
- 구축비용

## 미들웨어
- 분산 컴퓨팅 환경에서 응용 프로그램과 프로그램이 운영되는 환경 간에 원만한 통신이 이루어질 수 있도록 제어해주는 소프트웨어
- 운영체제와 소프트웨어 어플리케이션 사이에 위치 

### WAS
- 서버 계층에서 어플리케이션이 동작할 수 있는 환경을 제공하고 안정적인 트랜잭션 처리와 관리, 다른 이기종 시스테모가의 어플리케이션 연동을 지원

## 요구공학
- 사용자의 요구가 반영된 시스템을 개발하기 위해 사용자 요구사항에 대한 도출, 분석, 명세, 확인 하는 구조화된 활동
- 기능적 요구사항, 비기능적 요구사항 

## 요구사항 개발 단계 상세
- 요구사항 도출 관계 주요 기법
  - 인터뷰
  - 브레인스토밍
  - 델파이 기법
  - 롤 플레잉
  - 워크숍
  - 설문조사
- 요구사항 분석 단계 절차
  - 요구사항 분류
  - 개념 모델링 생성 및 분석
  - 요구사항 할당
  - 요구사항 협상
  - 정형 분석
  - 자료 흐름 지향 분석
  - 객체 지향 분석
- 요구사항 명세 단계 주요 기법
  - 비정형, 정형 명세 기법
  - 명확성
  - 완전성
  - 검증 가능성
  - 일관성
  - 수정 용이성
  - 추적 가능성
  - 개발 후 이용성
- 요구사항 확인 단계의 주요 기법
  - 정형 기술 검토 활용
    - 동료 검토
    - 워크 스루
    - 인스펙션
  - 프로토타이핑 활용
  - 모델 검증
  - 테스트 케이스 및 테스트를 통한 확인
  - CASE 도구 활용 검증
  - 요구사항 추적표를 통한 검증
- 상세 정형 기술 검토 기법
  - 관리 리뷰
  - 기술 리뷰
  - 인스펙션
  - 워크 스루
  - 감사

# 2. 데이터 입출력 구현

## 데이터 모델 표시 요소
- 연산: 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세
- 구조: 데이터베이스에 논리적으로 표현될 대상으로서의 개체 타입과 개체 타입 간의 조절
- 제약 조건: 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건

## 데이터 모델 절차
- 요구사항 분석
- 개념적 설계: 사용자의 트랜잭션을 모델링 하는 관계
- 논리적 설계: 트랜잭션의 인터페이스르 설계하는 단계
- 물리적 설계: 논리 데이터 모델을 특정 DBMS 특성 및 성능을 고려하여 물리적인 스키마를 만드는 단계

## 논리 데이터 모델링 속성
- 개체: 관리할 대상이 되는 실체
- 속성: 관리할 정보의 구체적 항목
- 관계: 개체간의 대응 관계

## ER 모델
- 현실 세계에 존재하는 데이터와 그들 간의 관계를 사람이 이해할 수 있는 형태로 명확하게 표현하기 위해서 가장 널리 사용되고 있는 모델

## 정규화
- 관게형 데이터 모델에서 데이터의 중복성을 제거하여 이상 현상을 방지하고, 데이터의 일관성 과 정확성을 유지하기 위해 무손실 분해하는 과정
- 정규화 단계
  - 1정규형: 원자값으로 구성 
  - 2정규형: 부분 함수 종속 제거 
  - 3정규형: 이행 함수 종속 제거 
  - BCNF: 결정자 후보키가 아닌 함수 종속 제거 
  - 4정규형: 다중 값 종속 제거
  - 5정규형: 조인 종속 제거 

## 이상 현상
- 데이터의 중복성으로 인해 린레잇녀을 조작할 때 발생하는 비합리적인 현상
- 삽입 이상: 정보 저장 시 해당 정보의 불필요한 세부정보를 입력해야 되는 경우
- 삭제 이상: 정보 삭제 시 원치 않는 다른 정보가 같이 삭제되는 경우
- 갱신 이상: 중복 데이터 중 특정 부분만 수정되어 중복된 값이 모순을 일으키는 경우

## 반 정규화
- 정규화된 개체, 속성, 관계에 대해 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법
- 기법
  - 테이블 병합
  - 테이블 분할
  - 중복 테이블 추가 
  - 컬럼 중복화 
  - 중복 관계 추가

## 인덱스 
- 검색 연산의 최적화를 위해 데이터베이스 내 열에 대한 정보를 구성한 데이터 구조
- 종류
  - 순서 인덱스: 데이터가 정렬된 순서로 생성되는 인덱스
  - 해시 인덱스: 해시 함수에 의해 직접 데이터에 키 값으로 접근하는 인덱스
  - 비트맵 인덱스: 각 컬럼에 적은 개수 값이 저장된 경우 선택하는 인덱스
  - 함수기반 인덱스: 수식이나 함수를 적용하여 만든 인덱스
  - 단일 인덱스: 하나의 컬럼으로만 구성한 인덱스
  - 결합 인덱스: 두 개 이상의 컬럼으로 구성한 인덱스
  - 클러스터드 인덱스: 기본 키 기준으로 레코드를 묶어서 저장하는 인덱스

### 인덱스 스캔 방식
- 인덱스 범위 스캔
- 인덱스 전체 스캔
- 인덱스 단일 스캔
- 인덱스 생략 스캔

## 파티션
- 종류
  - 레인지 파티셔닝: 연속적인 숫자나 날짜를 기준
  - 해시 파티셔닝: 파티션 키의 해시 값에 의한 파티셔닝 
  - 리스트 파티셔닝: 특정 파티션에 저장 될 데이터에 대한 명시적 제어가 가능한 파티셔닝
  - 컴포지트 파티셔닝: 2개 이상의 파티셔닝을 결합하는 파티셔닝
  - 라운드로빈 파티셔닝: 라운드로빈 분할로 회전하면서 새로운 행이 파티션에 할당
- 장점
  - 성능 향상
  - 가용성 향상
  - 백업 가능
  - 경합 감소

## 데이터베이스
- 다수의 인원, 시스템 또는 프로그램이 사용할 목적으로 통합되어 관리되는 데이터 집합
- 정의
  - 통합된 데이터: 자료의 중복을 배제한 데이터 모임
  - 저장된 데이터: 저장 매체에 저장된 데이터
  - 운영 데이터: 조직의 업무를 수행하는데 필요한 데이터
  - 공용 데이터: 여러 어플리케이션, 시스템들이 공동으로 사용하는 데이터
- 특성
  - 실시간 접근성
  - 계속적인 변화
  - 동시 공용
  - 내용 참조
- 종류
  - 파일 시스템: ISAM, VSAM
  - RDBMS
  - 계층형 데이터베이스 관리 시스템(HDBMS): 데이터를 상하 종속적인 관계로 계층화하여 관리하는 데이터베이스
  - 네트워크 데이터베이스 관리 시스템(NDBMS): 데이터의 구조를 네트워크의 망상 형태로 표현한 데이터 모델

## DBMS
- 데이터 관리의 복잡성을 해결하는 동시에 데이터 추가, 변경, 검색, 삭제 및 백업, 복구, 보안 등의 기능을 지원하는 소프트웨어
- 유형
  - 키-값
  - 컬럼 기반 데이터 저장
  - 문서 저장
  - 그래프
- 특징
  - 일관성
  - 무결성
  - 회복성
  - 보안성
  - 효율성

  ## 빅 데이터
  - 주어진 비용, 시간 내에 처리 가능한 데이터 범위를 넘어서는 수십 페타 크기의 비정형 데이터
  - 특성
    - 데이터의 양(Volume)
    - 데이터의 다양성(Variety)
    - 데이터의 속도(Velocity)
    - 데이터의 진실성(Veracity)
    - 데이터의 가치(Value)
    - 데이터의 정확성(Validity)
    - 데이터의 휘발성(Volatility)

## NoSQL
- 데이터 저장에 고정된 테이블 스키마가 필요하지 않고 조인 연산을 사용할 수 없는 수평적으로 확장이 가능한 DBMS

## 데이터 마이닝
- 대규모로 저장된 데이터 안에서 체계적이고 자동적으로 통계적 규칙이나 패턴을 찾아내는 기술
- 기법
  - 분류 규칙: 과거 데이터로부터 특성을 찾아내어 분류모형을 만들어 이를 토대로 새로운 레코드의 결과값을 예측하는 기법 
  - 연관 규칙: 데이터 안에 존재하는 항목들 간의 종속 관계를 찾아내는 기법 
  - 연속 규칙: 연관 규칙에 시간 관련 정보가 포함된 형태의 기법
  - 데이터 군집화: 대상 레코드들을 유사한 특성을 지닌 몇 개의 소그룹으로 분할하는 작업

## 관계 대수
- 관계형 데이터베이스에서 원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 절차적 정형 언어

### 일반 집합 연산자
- 합집합
- 교집합
- 차집합
- 카티션 프로덕트

### 순수 관계 연산자
- 셀렉트
- 프로젝트
- 조인
- 디비전

# 3. 통합 구현

## XML(eXtensible Markup Language)
- 특수한 목적을 갖는 마크업 언어를 만드는 데 사용되는 다목적 마크업 언어
- 사용자가 직접 문서의 태그를 정의할 수 있으며, 다른 사용자가 정의한 태그를 사용할 수 있다.
- 트리 구조로 구성되어 있어 상위 태그는 여러 개의 하위 태그를 가질 수 있다.

## SOAP(Simple Object Access Protocol)
- 네트워크 상에서 HTTP 등을 이용하여 XML 을 교환하기 위한 통신 규약
- 기본적으로 HTTP 기반에서 동작하기 때문에 프록시와 방화벽의 영향없이 통신할 수 있다.

## WSDL(Web Services Description Language)
- 웹 서비스와 관련된 서식이나 프로토콜 등을 표준적인 방법으로 기술하고 게시하기 위한 언어
- XML 로 작성되며, UDDI 의 기초가 된다.
- SOAP, XML 스키마와 결합하여 인터넷에서 웹 서비스를 제공하기 위해 사용된다.

# 4. 서버 프로그램 구현

## 개발 도구의 분류
- 빌드 도구: 작성한 코드의 빌드 및 배포를 수행하는 도구
- 구현 도구: 개발자의 코드 작성과 디버깅, 수정 등과 같은 작업을 지원하는 도구
- 테스트 도구: 코드의 기능 검증과 전체의 품질을 높이기 위해 사용하는 도구
- 형상 관리 도구: 개발자들이 작성한 코드와 리소스 등 산출물에 대한 버전 관리를 위한 도구 

## 형상 관리
- 코드와 리소스 등 산출물에 대한 버전 관리를 위한 활동
- 절차
  - 형상 식별
  - 형상 통제
  - 형상 감사
  - 형상 기록
- 소프트웨어 형상 관리 도구 유형
  - 공유 폴더 방식(RCS)
  - 클라이언트/서버 방식(SVN)
  - 분산 저장소 방식(Git)
- 소프트웨어 형상 관리 도구별 특징
  - CVS: 서버와 클라이언트로 구성되어 있고, 다수의 인원이 동시에 범용적인 운영체제로 접근 가능한 관리 도구 
  - SVN: 하나의 서버에서 소스를 쉽고 유용하게 관리할 수 있는 도구 
  - RCS: 소스 파일의 수정을 한 사람만으로 제한하여 다수의 사람이 파일의 수정을 동시에 할 수 없도록 파일 잠금 방식으로 관리
  - Git: 속도에 중점을 둔 분산형 버전 관리 시스템
  - Clear case: 복수의 서버, 클라이언트 구조이며 확장성을 기할 수 있음

## 모듈
- 그 자체로 하나의 완전한 기능을 수행할 수 있는 독립된 실체

### 모듈화
- 소프트웨어의 성능을 향상시키거나 복잡한 시스템의 수정, 재사용, 유지 관리 등이 용이하도록 기능 단위의 모듈로 분해하는 설계 및 구현 기법
- 기법
  - 루틴: 특정 동작을 수행하는 일련의 코드로 기능을 가진 명령들의 모임
  - 메인 루틴, 서브 루틴

## 응집도
- 모듈의 독립성을 나타내는 정도로, 모듈 내부 구성요소간 연관 정도
- 유형
  - 우연적 응집도(Coincidental Cohesion): 모듈 내부의 각 구성요소가 연관이 없을 경우의 응집도
  - 논리적 응집도(Logical Cohesion): 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리 
  - 시간적 응집도(Temporal Cohesion): 연관된 기능보다 특정 시간에 처리되어야 하는 활동들의 모음
  - 절차적 응집도(Procedural Cohesion): 다수의 관련 기능을 가질 때 모듈 안의 구성요소들이 그 기능을 순차적으로 수행할 경우
  - 통신적 응집도(Communication Cohesion): 동일한 입력돠 출력을 사용하여 다른 기능을 수행하는 활동들의 모음 
  - 순차적 응집도(Sequential Cohesion): 모듈 내에서 한 활동으로부터 나온 출력값을 다른 활동들이 사용할 경우 
  - 기능적 응집도(Functional Cohesion): 모든 기능이 단일한 목적을 위해 수행되는 경우

## 결합도
- 외부 모듈가의 연관성, 상호의존성
- 유형
  - 내용 결합도(Content Coupling): 모듈 내부의 변수나 기능을 다른 모듈에서 사용하는 경우
  - 공통 결합도(Common Coupling): 파라미터가 아닌 모듈 밖에 선언되어 있는 전역변수를 참조하고 갱식하는 식의 결합도 
  - 외부 결합도(External Coupling): 모듈이 외부에서 도입된 데이터 포맷, 디바이스 인터페이스를 공유할 경우
  - 제어 결합도(Control Coupling): 모듈이 다른 모듈의 내부 논리 조직을 제어하기 위한 목적으로 제어 신호를 이용하여 통신하는 경우 결합도 
  - 스탬프 결합도(Stamp Coupling): 모듈 간의 인터페이스로 배열이나 객체, 구조 등이 전달되는 경우
  - 자료 결합도(Data Coupling): 모듈 간 인터페이스로 전달되는 파라미터를 통해서만 모듈간 상호 작용이 일어나는 경우 

## 팬인/ 팬아웃
- 팬인: 어떤 모듈을 제어하는 모듈의 수
- 팬아웃: 어떤 모들에 의해 제어되는 모듈의 수

## 공통 모듈 테스트 
- 화이트박스 테스트: 응용프로그램 내부 구조와 동작을 검사하는 방식
- 메서드 기반 테스트: 공통 모듈의 외부에 공개된 메서드 기반의 테스트
- 화면 기반 테스트: 화면 단위로 단위 모듈을 개발 후 화면에 직접 데이터를 입력하여 테스트를 수행
- 테스트 드라이버/ 테스트 스텁 활용 테스트: 기능을 테스트 할 수 있는 화면 또는 하위 모듈이 구현되지 않은 경우 해당 기법 사용

## 배치 프로그램
- 사용자와의 상호 작용 없이 일련의 작업들을 작업 단위로 묶어 정기적으로 반복 수행하거나 정해진 규칙에 따라 일괄 처리하는 방식
- 유형
  - 이벤트 배치: 사전에 정의해 둔 조건 충족 시 자동으로 실행
  - 온디멘드 배치: 사용자의 명시적 요구가 있을 때 실행
  - 정기 배치: 정해진 시점에 정기적으로 실행

## 배치 스케줄러
- 일괄 처리를 위해 주기적으로 발생하거나 반복적으로 발생하는 작업을 지원하는 도구 
- 종류
  - 스프링 배치 
  - 쿼츠 스케줄러 

## 크론 표현식
- 초/분/시/일/월/요/년 

# 5. 인터페이스 구현

## 인터페이스 명세서
- 데이터의 송수신 시스템 간의 데이터 저장과 속성 등의 상세 내역을 포함 

### 인터페이스 명세서 중요 항목
- 인터페이스 ID
- 최대 처리 횟수
- 데이터 크기 
- 시스템 정보
- 데이터 정보

### 상세 기능별 인터페이스 명세서 주요 항목
- 인터페이스 ID
- 인터페이스명
- 오퍼레이션명
- 오퍼레이션 개요
- 사전 조건
- 사후 조건
- 파라미터
- 반환 값

## EAI(Enterprise Application Integration)
- 기업에서 운영되는 서로 다른 플랫폼 및 어플리케이션 간의 정보를 전달, 연계, 통합이 가능하도록 해주는 솔루션
- 구축 유형
  - 포인트 투 포인트: 기초적인 어플리케이션 통합 방법으로 1:1 단순 통합
  - 허브 앤 스포크: 단일한 접점의 허브 시스템을 통하여 데이터를 전송하는 중앙 집중식
  - 메시지 버스: 어플리케이션 사이 미들웨어를 두어 연계하는 미들웨어 통합 방식
  - 하이브리드: 그룹 내부는 허브 앤 스포크를 사용 그룹 간에는 메세지 버스 방식을 사용

## ESB(Enterprise Service Bus)
- 기업에서 운영되는 서로 다른 플랫폼 간을 하나의 시스템으로 관리 운영할 수 있도록 서비스 중심의 통합을 지향하는 아키텍처 
- 버스를 중심으로 각각 프로토콜이 호환할 수 있도록 어플리케이션의 통합을 느슨한 결합 방식으로 지원 

## JSON(JavaScript Object Notation)
- 키-값 쌍으로 이루어진 객체를 전달하기 위해 인간이 읽을 수 있는 텍스트를 사용하는 개병형 표준 포맷

## XML(eXtensible Markup Language)
- HTML의 단점을 보완한 인터넷 언어로 송수신 시스템 간 데이터 연계의 편의성을 위해서 전송되는 데이터 구조를 동일한 형태로 정의
- 사용자가 직접 문서의 태그를 정의할 수 있음

## AJAX(Asynchronous JavaScript And XML)
- 자바스크립트를 사용하여 비동기적으로 XML 데이터를 교환하고 조작하기 위한 웹 기술 
- XMLHttpRequest 를 사용하여 페이지 전체가 아닌 일부 페이지 데이터만을 로드하는 기술
- 주요 기술
  - XMLHttpRequest
  - JavaScript
  - XML 
  - DOM 
  - XSLT 
  - HTML
  - CSS

## REST(Representational State Transfer)
- 웹과 간은 분산 하이퍼미디어 환경에서 자원의 존재/상태 정보를 표준화된 HTTP 메서드로 주고 받는 웹 아키텍처 
- 리소스, 메서드, 메시지 3가지 요소로 구성 

## 시큐어 코딩 가이드 적용 대상
- 입력 데이터 검증 및 표현
- 보안 기능
- 시간 및 상태
- 에러 처리
- 코드 오류
- 캡슐화
- API 오용

## 데이터베이스 암호화 알고리즘 유형
- 대칭 키 암호화 알고리즘
  - 암복호화에 같은 암호 키를 쓰는 알고리즘
  - ARIA 128/192/256, SEED
- 비대칭 키 암호화 알고리즘
  - 공개키는 누구나 알 수 있지만 비밀키는 키 소유자만이 알 수 있도록, 공개키와 비밀키를 사용하는 알고리즘
  - RSA, ECC, ECDSA
- 해쉬 암호화 알고리즘
  - 해시값으로 원래 입력값을 찾아낼 수 없는 일방향성의 특성을 가진 알고리즘
  - SHA-256/384/512, HAS-160

## 데이터베이스 암호화 기법:
- API 방식: 어플리케이션 레벨에서 암호 모듈을 적용하는 방식
- Plug-in 방식: 암복호화 모듈이 DB 서버에 설치된 방식
- TDE 방식: DB의 DBMS 커널이 자체적으로 암복호화 기능을 수행하는 방식
- Hybrid 방식: API 방식과 Plug-in 방식을 혼합하여 사용하는 방식

## IPSec
- ip 계층에서 무결성과 인증을 보장하는 인증 해더와 기밀성을 보장하는 암호화를 이용하여 양 종단 간 구간에 보안
- 동작모드: 전송, 터널
- 프로토콜: AH, ESP, IKE
- 정책: SPD, SAD

## SSL/TLS
- 전송 계층과 응용 계층 사이에서 클라이언트와 서버 간의 웹 데이터 암호화, 상호 인증 및 전송시 데이터 무결성을 보장하는 프로토콜
- 인증 모드: 익명 몯, 서버 인증 모드, 클라이언트-서버 인증 모드

## S-HTTP
- 웹 상에서 네트워크 트래픽을 암호화하는 주요 방법 중 하나, 클라이언트-서버 간에 전송되는 모든 메시지를 각각 암호화하여 전송

## 인터페이스 구현 검증 도구 
- XUnit: 다양한 언어를 지원하는 단위 테스트 프레임워크
- STAF: 서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원
- FitNesse: 웹 기반 테스트 케이스 설계, 실행, 결과 확인 등을 지원
- NTAF: FitNesse 의 장점인 협업기능과 STAF 장점인 재사용 및 확장성을 통한 NHN의 테스트 자동화 프레임워크
- Selenium: 다양한 브라우저 및 개발 언어를 지원하는 웹 어플리케이션 테스트 프레임워크
- watir: Ruby 사용

# 6. 화면 설계

## 사용자 인터페이스 
- 사용자와 시스템 사이에서 의사소통할 수 있도록 고안된 물리적, 가상의 매개체
- 정보 기기나 소프트웨어의 홤녀 등에서 사람이 접하게 되는 화면