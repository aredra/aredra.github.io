# 원문, 출처 : [별의 블로그](https://starrykss.tistory.com/1856)


# 1. 요구사항 확인

## 소프트웨어 생명주기 모델
- 소프트웨어 생명주기: 시스템의 요구분석부터 유지보수까지 전 공정을 체계화한 절차
- 시스템이 개발될 때부터 운용과 유지보수를 거쳐 생애를 마칠 때까지 어떠한 순서를 밟는지에 대한 작업 프로세스를 모델화 한 것
- 프로세스 
  - 요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수 
- 모델 종류
  - 폭포수 모델: 각 단계를 확실히 마무리 지은 후 다음 단계로 넘어가는 모델
    - 타당성 검토 -> 계획 -> 요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수 
  - 프로토타이핑 모델: 고객이 요구한 주요기능을 프로토타입을 구현 후 피드백을 반영하며 만들어가는 모델
  - 나선형 모델: 시스템 개발 시 위험을 취소화하기 위해 점진적으로 완벽한 시스템으로 개발하는 모델
    - 계획 및 정의 -> 위험 분석 -> 개발 -> 고객 평가
  - 반복적 모델: 구축 대상을 나누어 병렬적으로 개발 후 통합하거나, 반복적으로 개발하여 점진적으로 완성시키는 모델

## 소프트웨어 개발 방법론
- 소프트웨어 개발 전 과정에 지속적으로 적용할 수 방법, 절차, 기법
  - 구조적 방법론: 전체 시스템을 기능에 따라 나누어 개발, 이를 통합하는 분할과 정복 접근 방식의 방법론
  - 정보공학 방법론: 정보 시스템 개발에 필요한 관리 절차와 작업 기법을 체계화한 방법론
  - 객체 지향 방법론: '객체'라는 기본 단위로 시스템을 분석 및 설계하는 방법론
  - 컴포넌트 기반 방법론: 소프트웨어를 구성하는 컴포넌트를 조립해서 하나의 새로운 응용 프로그램을 작성하는 방법론
  - 애자일 방법론: 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적용하며, 효율적으로 개발할 수 있는 **신속 적응적 경량 개발 방법론**
  - 제품 계열 방법론: 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론

## 애자일 방법론 기법
- XP(extreme Programming): 의사소통 개선과 즉각적 피드백으로 소프트웨어 품질을 높이기 위한 방법론
  - 5가지 가치
    - 용기, 단순성, 의사소통, 존중, 피드백
  - 12가지 원리
    - 짝 프로그래밍
    - 공동 코드 소유
    - 지속적인 통합
    - 계획 세우기
    - 작은 릴리즈
    - 메타포어 
    - 간단한 디자인
    - 테스트 기반 개발
    - 리팩토링
    - 40시간 작업
    - 고객 상주
    - 코드 표준
- 스크럼: 매일 정해진 시간, 장소에서 짧은 시간의 개발을 하는 팀을 위한 프로젝트 관리 중심 방법론
  - 백로그: 제품과 프로젝트에 대한 요구사항
  - 스프린트: 2~4주의 짧은 개발 기간의 반복적 수행으로 개발품질 향상
  - 스크럼 미팅: 매일 15분 정도 미팅으로 To-Do list 계획 수립
  - 스크럼 마스터: 프로젝트 리더, 스크럼 수행 시 문제 인지 및 해결하는 사람
  - 스프린트 회고: 스프린트 주기를 되돌아보며 정해놓은 규칙 준수 엽, 개선점 등을 확인 및 기록
  - 번 다운 차트: 남아있는 백로그 대비 시간을 시각적으로 표현한 차트
- 린: 도요타의 린 시스템 품질기법을 소프트웨어 개발 프로세스에 적용해서 낭비 요소를 제거하여 품질을 향상시킨 방법
  - JIT, 칸반 보드 사용 
  - 7가지 원칙
    - 낭비 제거
    - 품질 내재화 
    - 지식 창출 
    - 늦은 확정 
    - 빠른 인도
    - 사람 존중 
    - 전체 최적화

## 객체 지향 분석
- 사용자의 요구사항을 분석하여 요구된 문제와 관련된 모든 클래스, 속성, 연산, 관계를 정의하여 모델링하는 기법
- 종류
  - OOSE: 야콥슨, 유스케이스에 의한 접근 방법으로 유스케이스를 모든 모델의 근간으로 활용하는 방법론, 야콥슨
  - OMT: 럼바우, 그래픽 표기법을 이용하여 소프트웨어 구성요소를 모델링하는 방법론
    - 객체 모델링: 객체 다이어그램 활용
    - 동적 모델링: 시간의 흐름에 따라 객체들 사이의 제어 흐름, 동작 순서 등의 동적인 행위를 표현, 상태 다이어그램
    - 기능 모델링: 프로세스의 자료 흐름을 중심으로 처리 과정 표현, 자료 흐름도 활용
  - OOD: 부치, 설계 문서화를 강조하여 다이어그램 중심으로 개발하는 방법론

## 비용 산정 모형
- 소프트웨어 규모 파악을 통한 투입자원, 소요시간을 파악하여 실행 가능한 계획을 수립하기 위해 비용을 산정하는 방식
- 하향식 산정 방법
  - 전문가 판단
  - 델파이 기법
- 상향식 산정 방법
  - 코드 라인 수(LoC): 소프트웨어 각 기능의 원시 코드 라인 수의 낙관치, 중간치, 비관치를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 방식
  - Man Month: 한 사람이 1개월 동안 할 수 있는 일의 양을 기준으로 프로젝트 비용을 산정하는 방식
  - COCOMO 모형: 보헴, 비용산정 결과는 프로젝트를 완성하는 데 필요한 노력으로 산정
    - 조직형: 5만 라인 이하 
    - 반 분리형: 30만 라인 이하 
    - 임베디드형: 30만 라인 초과 
  - Putnam 모형: 생명주기 예측 모형, 각 단계별로 요구할 인력의 분포를 가정하는 방식
  - FP 모형: 요구 기능을 증가시키는 인자별로 가중치를 부여하고, 요인별 가중치를 합산하여 총 기능의 점수를 계산하여 비용을 산정하는 방식

## 일정 관리 모델
- 프로젝트가 일정 기한 내에 적절하게 완료도리 수 있도록 관리하는 모델
- 주 공정법(CPM): 여러가지 수행 순서가 얽혀 있는 프로젝트의 일정을 계산하는 방법, 가장 긴 시간이 걸리는 경로를 계산한다.
- PERT(Program Evaluation and Review Technique): 일의 순서를 계획적으로 정리하기 위한 수렴 기법 3점 추정방식을 통해 일정을 관리하는 기법
- 중요 연쇄 프로젝트 관리(CCPM): 주 공정 연쇄법으로 자원 제약 사항을 고려하여 일정을 작성하는 기법

## 소프트웨어 아키텍쳐 4+1뷰
- 고객의 요구사항을 정리해 놓은 시나리오를 4개의 관점에서 바라보는 소프트웨어적인 접근 방식
- 체크 방법으로 유스케이스를 사용한다.
  - 유스케이스: 시스템이 엑터에게 제공해야 하는 기능으로서 시스템의 요구사항이자, 사용자 입장에서 바라본 시스템의 기능 
- 1(유스케이스 뷰) + 4(논리 뷰, 프로세스 뷰, 구현 뷰, 배포 뷰)
- 유스케이스 뷰: 유스케이스 또는 아키텍처를 도출하고 설계하며 다른 뷰를 검증하는데 사용되는 뷰
  - 사용자/설계자/개발자/테스트 관점 
- 논리 뷰: 시스템의 기능적인 요구사항이 어떻게 제공되는지 설명해주는 뷰
  - 설계자/개발자 관점
- 프로세스 뷰: 시스템의 비기능적인 속성으로서 자원의 효율적인 사용, 병행 실행, 비동기, 이벤트 처리 등을 표현한 뷰
  - 개발자/시스템 통합자 관점
- 구현 뷰: 개발 환경 안에서 정적인 소프트웨어 모듈의 구성을 보여주는 뷰
- 배포 뷰: 컴포넌트가 물리적인 아키텍처에 어떻게 배치되는가를 매핑해주는 뷰

## 소프트웨어 아키텍처 패턴
- 소프트웨어를 설계할 때 참조할 수 있는 전형적인 해결 방식
- 계층화 패턴: 시스템을 계층으로 구분하여 구성하는 패턴
- 클라이언트-서버 패턴: 하나의 서버와 다수의 클라이언트로 구성된 패턴
- 파이프-필터 패턴: 데이터 스트림을 생성하고 처리하는 시스템에서 사용 가능한 패턴
- 브로커 패턴: 분리된 컴포넌트들로 이루어진 분산 시스템에서 사용되고, 이 컴포넌트들은 원격 서비스 실행을 통해 상호 작용이 가능한 패턴
- 모델-뷰-컨트롤러 패턴: 대화형 어플리케이션을 모델, 뷰, 컨트롤러의 3개의 서비 시스템으로 구조화하는 패턴

## 소프트웨어 아키텍처 비용 평가 모델
- 아키텍처 접근벙이 품질 속성에 미치는 영향을 판단하고 아키텍처의 적합성을 평가하는 모델
- SACAA
  - SAAM: 변경 용이성과 기능성에 집중, 평가가 용이하며 경험이 없는 조직에서도 활용 가능한 비용 평가 모델
  - ATAM: 아키텍처 품질 속성을 만족시키는지 판단 및 품질 속성들의 이해 상충관계가지 평가하는 모델
  - CBAM: ATAM 바탕의 시스템 아키텍처 분석 중심으로 경제적 의사결정에 대한 요구를 충족하는 비용 평가 모델
  - ADR: 소프트웨어 아키텍처 구성요소 간 응집도를 평가하는 모델
  - ARID: 전체 아키첵처가 아닌 특정 부분에 대한 품질요소에 집중하는 비용 평가 모델

## 디자인 패턴
- 소프트웨어 공학의 스프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 패턴
- 디자인 패턴의 구성요소 
  - 패턴의 이름
  - 문제 및 배경
  - 솔루션
  - 사례
  - 결과 
  - 샘플코드
- 디자인 패턴 유형
  - 목적에 따른 구분: 생성, 구조, 행위
  - 범위에 따른 구분: 클래스, 객체
  - 생성 패턴: 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행하는 패턴
    - Builder: 복잡한 인스턴스를 조립하여 만드는 구조
    - Prototype: 처음부터 일반적인 원형을 만들어 놓고, 그것을 복사한 후 필요한 부분만 수정하여 사용하는 패턴
    - Factory Method: 상위 클래스에서 객체를 생헝하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 하는 방식
    - Abstract Factory: 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴
    - Singleton: 전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객첼르 어디에서든지 참조할 수 있도록 하는 패턴
  - 구조 패턴: 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴
    - Bridge: 기능의 클래스 계층과 구현의 클래스 계층을 연결하고, 구현부에서 추상 계층을 분리하여 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있는 패턴
    - Decorator: 기존에 구현되어 있는 클래스에 필요한 기능을 추가해 나가는 패턴
    - Facade: 단순한 인터페이스를 제공함으로서, 노드 간 결합도를 낮추어 시스템 구조에 대한 파악을 쉽게 하는 패턴
    - Flyweight: 클래스 경량화를 목적으로 하는 패턴, 여러 개의 가상 인스턴스를 제공하여 메모리를 절감
    - Proxy: 실제 객체에 대한 대리 객체, 실제 객체 접근 이전에 필요한 행동을 할 수 있음. 정보 은닉의 역할도 수행하는 패턴
    - Composite: 객체들의 관계를 트리 구조로 구성하여, 부분-전체 계층을 표현하는 패턴
    - Adapter: 기존에 생성된 클래스를 재사용 할 수 있도록 중간에서 맞춰주는 역할을 하는 인터페이스를 만드는 패턴
  - 행위 패턴: 클래스나 객체들이 상호 작용하는 방법과 역할 분담을 다루는 패턴
    - Mediator: 중재자를 두고, 중재자에게 모든 것을 요구하여 통신의 빈도수를 줄여 객체 지향의 목표를 달성하는 패턴
    - Interpreter: 구체적으로 구문을 나누고 그 분리된 구문의 해석을 맡는 클래스를 작성하여 여러 형태의 구문을 해석할 수 있게 하는 패턴
    - Iterator: 컬렉션의 구현 방법을 노출시키지 않으면서 안에 들어있는 모든 항목에 접근할 방법을 제공하는 디자인 패턴
    - Template Method: 작업의 일부분을 서브 클래스로 캡슐화 하여 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴
    - Observer: 일대 다의 의존성을 가지며, 상호 작용을 하는 객체 사이에서는 가능하면 느슨하게 결합하는 패턴
    - State: 객체 상태를 캡슐화하여 클래스화 함.
    - Visitor: 각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도의 클래스를 만들고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 하는 패턴
    - Command: 각 명령이 들어오면 그에 맞는 서브 클래스가 선택되어 실행되는 특징을 갖는 패턴
    - Strategy: 알고리즘 군을 정의하고, 같은 알고리즘을 각각의 클래스로 캡슐화한 다음, 필요할 때 서로 교환해서 사용할 수 있게 하는 패턴
    - Memento: 클래스 설계 관점에서 객체의 정보를 저장할 필요가 있을 때 적용하는 패턴
    - Chain of Responsibility: 연결되어 있는 경우에 따라 동적으로 다르게 처리될 수 있도록 연결한 패턴

## 분석 산출물의 종류
- 정보 시스템 구성 현황
- 정보 시스템 기능 구성도
- 인터페이스 현황
- 현행 시스템 아키텍처 구성도
- 소프트웨어 구성도
- 하드웨어 구성도
- 네트워크 구성도

## OS 
- 컴퓨터 시스템이 제공하는 모든 하드웨어, 소프트웨어를 사용할 수 있게 해주고, 사용자와 하드웨어 간의 인터페이스를 담당하는 프로그램
- 신뢰도, 성능, 기술지원, 주변기기, 구축비용

## OSI 7계층
- 물리 계층: 0, 1 비트 정보를 회선에서 보내기 위한 전기적 신호 변환
  - 프로토콜: RS-232C
  - 전송단위: 비트
- 데이터 링크 계층: 데이터 전송 제어
  - 프로토콜: 이더넷
  - 전송단위: 프레임
- 네트워크 계층: 단말 간 데이터 전송의 최적 경로를 제공
  - 프로토콜: IP, ICMP
  - 전송단위: 패킷
- 전송 계층: 신뢰성 있는 통신 보장, 데이터 분할과 재조립, 흐름, 오류, 혼잡 제어
  - 프로토콜: TCP, UDP
  - 전송단위: 세그먼트
- 세션 계층: 연결 접속 및 동기 제어
  - 프로토콜: SSH, TLS
  - 전송단위: 데이터 
- 표현 계층: 데이터 형식 설정과 부호 교환, 암/복호화
  - 프로토콜: JPEG, MPEG
  - 전송단위: 데이터
- 응용 계층: 사용자와 네트워크 간 응용서비스 연결
  - 프로토콜: FTP, SMTP, HTTP, HTTPS
  - 전송단위: 데이터

## DBMS 현행 시스템 분석 시 고려사항
- 가용성
- 성능
- 상호 호환성
- 기술지원
- 구축비용

## 미들웨어
- 분산 컴퓨팅 환경에서 응용 프로그램과 프로그램이 운영되는 환경 간에 원만한 통신이 이루어질 수 있도록 제어해주는 소프트웨어
- 운영체제와 소프트웨어 어플리케이션 사이에 위치 

### WAS
- 서버 계층에서 어플리케이션이 동작할 수 있는 환경을 제공하고 안정적인 트랜잭션 처리와 관리, 다른 이기종 시스테모가의 어플리케이션 연동을 지원

## 요구공학
- 사용자의 요구가 반영된 시스템을 개발하기 위해 사용자 요구사항에 대한 도출, 분석, 명세, 확인 하는 구조화된 활동
- 기능적 요구사항, 비기능적 요구사항 

## 요구사항 개발 단계 상세
- 요구사항 도출 관계 주요 기법
  - 인터뷰
  - 브레인스토밍
  - 델파이 기법
  - 롤 플레잉
  - 워크숍
  - 설문조사
- 요구사항 분석 단계 절차
  - 요구사항 분류
  - 개념 모델링 생성 및 분석
  - 요구사항 할당
  - 요구사항 협상
  - 정형 분석
  - 자료 흐름 지향 분석
  - 객체 지향 분석
- 요구사항 명세 단계 주요 기법
  - 비정형, 정형 명세 기법
  - 명확성
  - 완전성
  - 검증 가능성
  - 일관성
  - 수정 용이성
  - 추적 가능성
  - 개발 후 이용성
- 요구사항 확인 단계의 주요 기법
  - 정형 기술 검토 활용
    - 동료 검토
    - 워크 스루
    - 인스펙션
  - 프로토타이핑 활용
  - 모델 검증
  - 테스트 케이스 및 테스트를 통한 확인
  - CASE 도구 활용 검증
  - 요구사항 추적표를 통한 검증
- 상세 정형 기술 검토 기법
  - 관리 리뷰
  - 기술 리뷰
  - 인스펙션
  - 워크 스루
  - 감사

# 2. 데이터 입출력 구현

## 데이터 모델 표시 요소
- 연산: 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세
- 구조: 데이터베이스에 논리적으로 표현될 대상으로서의 개체 타입과 개체 타입 간의 조절
- 제약 조건: 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건

## 데이터 모델 절차
- 요구사항 분석
- 개념적 설계: 사용자의 트랜잭션을 모델링 하는 관계
- 논리적 설계: 트랜잭션의 인터페이스르 설계하는 단계
- 물리적 설계: 논리 데이터 모델을 특정 DBMS 특성 및 성능을 고려하여 물리적인 스키마를 만드는 단계

## 논리 데이터 모델링 속성
- 개체: 관리할 대상이 되는 실체
- 속성: 관리할 정보의 구체적 항목
- 관계: 개체간의 대응 관계

## ER 모델
- 현실 세계에 존재하는 데이터와 그들 간의 관계를 사람이 이해할 수 있는 형태로 명확하게 표현하기 위해서 가장 널리 사용되고 있는 모델

## 정규화
- 관게형 데이터 모델에서 데이터의 중복성을 제거하여 이상 현상을 방지하고, 데이터의 일관성 과 정확성을 유지하기 위해 무손실 분해하는 과정
- 정규화 단계
  - 1정규형: 원자값으로 구성 
  - 2정규형: 부분 함수 종속 제거 
  - 3정규형: 이행 함수 종속 제거 
  - BCNF: 결정자 후보키가 아닌 함수 종속 제거 
  - 4정규형: 다중 값 종속 제거
  - 5정규형: 조인 종속 제거 

## 이상 현상
- 데이터의 중복성으로 인해 린레잇녀을 조작할 때 발생하는 비합리적인 현상
- 삽입 이상: 정보 저장 시 해당 정보의 불필요한 세부정보를 입력해야 되는 경우
- 삭제 이상: 정보 삭제 시 원치 않는 다른 정보가 같이 삭제되는 경우
- 갱신 이상: 중복 데이터 중 특정 부분만 수정되어 중복된 값이 모순을 일으키는 경우

## 반 정규화
- 정규화된 개체, 속성, 관계에 대해 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법
- 기법
  - 테이블 병합
  - 테이블 분할
  - 중복 테이블 추가 
  - 컬럼 중복화 
  - 중복 관계 추가

## 인덱스 
- 검색 연산의 최적화를 위해 데이터베이스 내 열에 대한 정보를 구성한 데이터 구조
- 종류
  - 순서 인덱스: 데이터가 정렬된 순서로 생성되는 인덱스
  - 해시 인덱스: 해시 함수에 의해 직접 데이터에 키 값으로 접근하는 인덱스
  - 비트맵 인덱스: 각 컬럼에 적은 개수 값이 저장된 경우 선택하는 인덱스
  - 함수기반 인덱스: 수식이나 함수를 적용하여 만든 인덱스
  - 단일 인덱스: 하나의 컬럼으로만 구성한 인덱스
  - 결합 인덱스: 두 개 이상의 컬럼으로 구성한 인덱스
  - 클러스터드 인덱스: 기본 키 기준으로 레코드를 묶어서 저장하는 인덱스

### 인덱스 스캔 방식
- 인덱스 범위 스캔
- 인덱스 전체 스캔
- 인덱스 단일 스캔
- 인덱스 생략 스캔

## 파티션
- 종류
  - 레인지 파티셔닝: 연속적인 숫자나 날짜를 기준
  - 해시 파티셔닝: 파티션 키의 해시 값에 의한 파티셔닝 
  - 리스트 파티셔닝: 특정 파티션에 저장 될 데이터에 대한 명시적 제어가 가능한 파티셔닝
  - 컴포지트 파티셔닝: 2개 이상의 파티셔닝을 결합하는 파티셔닝
  - 라운드로빈 파티셔닝: 라운드로빈 분할로 회전하면서 새로운 행이 파티션에 할당
- 장점
  - 성능 향상
  - 가용성 향상
  - 백업 가능
  - 경합 감소

## 데이터베이스
- 다수의 인원, 시스템 또는 프로그램이 사용할 목적으로 통합되어 관리되는 데이터 집합
- 정의
  - 통합된 데이터: 자료의 중복을 배제한 데이터 모임
  - 저장된 데이터: 저장 매체에 저장된 데이터
  - 운영 데이터: 조직의 업무를 수행하는데 필요한 데이터
  - 공용 데이터: 여러 어플리케이션, 시스템들이 공동으로 사용하는 데이터
- 특성
  - 실시간 접근성
  - 계속적인 변화
  - 동시 공용
  - 내용 참조
- 종류
  - 파일 시스템: ISAM, VSAM
  - RDBMS
  - 계층형 데이터베이스 관리 시스템(HDBMS): 데이터를 상하 종속적인 관계로 계층화하여 관리하는 데이터베이스
  - 네트워크 데이터베이스 관리 시스템(NDBMS): 데이터의 구조를 네트워크의 망상 형태로 표현한 데이터 모델

## DBMS
