# 원문, 출처 : [별의 블로그](https://starrykss.tistory.com/1856)


# 요구사항 확인

## 소프트웨어 생명주기 모델
- 소프트웨어 생명주기: 시스템의 요구분석부터 유지보수까지 전 공정을 체계화한 절차
- 시스템이 개발될 때부터 운용과 유지보수를 거쳐 생애를 마칠 때까지 어떠한 순서를 밟는지에 대한 작업 프로세스를 모델화 한 것
- 프로세스 
  - 요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수 
- 모델 종류
  - 폭포수 모델: 각 단계를 확실히 마무리 지은 후 다음 단계로 넘어가는 모델
    - 타당성 검토 -> 계획 -> 요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수 
  - 프로토타이핑 모델: 고객이 요구한 주요기능을 프로토타입을 구현 후 피드백을 반영하며 만들어가는 모델
  - 나선형 모델: 시스템 개발 시 위험을 취소화하기 위해 점진적으로 완벽한 시스템으로 개발하는 모델
    - 계획 및 정의 -> 위험 분석 -> 개발 -> 고객 평가
  - 반복적 모델: 구축 대상을 나누어 병렬적으로 개발 후 통합하거나, 반복적으로 개발하여 점진적으로 완성시키는 모델

## 소프트웨어 개발 방법론
- 소프트웨어 개발 전 과정에 지속적으로 적용할 수 방법, 절차, 기법
  - 구조적 방법론: 전체 시스템을 기능에 따라 나누어 개발, 이를 통합하는 분할과 정복 접근 방식의 방법론
  - 정보공학 방법론: 정보 시스템 개발에 필요한 관리 절차와 작업 기법을 체계화한 방법론
  - 객체 지향 방법론: '객체'라는 기본 단위로 시스템을 분석 및 설계하는 방법론
  - 컴포넌트 기반 방법론: 소프트웨어를 구성하는 컴포넌트를 조립해서 하나의 새로운 응용 프로그램을 작성하는 방법론
  - 애자일 방법론: 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적용하며, 효율적으로 개발할 수 있는 **신속 적응적 경량 개발 방법론**
  - 제품 계열 방법론: 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론

## 애자일 방법론 기법
- XP(extreme Programming): 의사소통 개선과 즉각적 피드백으로 소프트웨어 품질을 높이기 위한 방법론
  - 5가지 가치
    - 용기, 단순성, 의사소통, 존중, 피드백
  - 12가지 원리
    - 짝 프로그래밍
    - 공동 코드 소유
    - 지속적인 통합
    - 계획 세우기
    - 작은 릴리즈
    - 메타포어 
    - 간단한 디자인
    - 테스트 기반 개발
    - 리팩토링
    - 40시간 작업
    - 고객 상주
    - 코드 표준
- 스크럼: 매일 정해진 시간, 장소에서 짧은 시간의 개발을 하는 팀을 위한 프로젝트 관리 중심 방법론
  - 백로그: 제품과 프로젝트에 대한 요구사항
  - 스프린트: 2~4주의 짧은 개발 기간의 반복적 수행으로 개발품질 향상
  - 스크럼 미팅: 매일 15분 정도 미팅으로 To-Do list 계획 수립
  - 스크럼 마스터: 프로젝트 리더, 스크럼 수행 시 문제 인지 및 해결하는 사람
  - 스프린트 회고: 스프린트 주기를 되돌아보며 정해놓은 규칙 준수 엽, 개선점 등을 확인 및 기록
  - 번 다운 차트: 남아있는 백로그 대비 시간을 시각적으로 표현한 차트
- 린: 도요타의 린 시스템 품질기법을 소프트웨어 개발 프로세스에 적용해서 낭비 요소를 제거하여 품질을 향상시킨 방법
  - JIT, 칸반 보드 사용 
  - 7가지 원칙
    - 낭비 제거
    - 품질 내재화 
    - 지식 창출 
    - 늦은 확정 
    - 빠른 인도
    - 사람 존중 
    - 전체 최적화

## 객체 지향 분석
- 사용자의 요구사항을 분석하여 요구된 문제와 관련된 모든 클래스, 속성, 연산, 관계를 정의하여 모델링하는 기법
- 종류
  - OOSE: 야콥슨, 유스케이스에 의한 접근 방법으로 유스케이스를 모든 모델의 근간으로 활용하는 방법론, 야콥슨
  - OMT: 럼바우, 그래픽 표기법을 이용하여 소프트웨어 구성요소를 모델링하는 방법론
    - 객체 모델링: 객체 다이어그램 활용
    - 동적 모델링: 시간의 흐름에 따라 객체들 사이의 제어 흐름, 동작 순서 등의 동적인 행위를 표현, 상태 다이어그램
    - 기능 모델링: 프로세스의 자료 흐름을 중심으로 처리 과정 표현, 자료 흐름도 활용
  - OOD: 부치, 설계 문서화를 강조하여 다이어그램 중심으로 개발하는 방법론

## 비용 산정 모형
- 소프트웨어 규모 파악을 통한 투입자원, 소요시간을 파악하여 실행 가능한 계획을 수립하기 위해 비용을 산정하는 방식
- 하향식 산정 방법
  - 전문가 판단
  - 델파이 기법
- 상향식 산정 방법
  - 코드 라인 수(LoC): 소프트웨어 각 기능의 원시 코드 라인 수의 낙관치, 중간치, 비관치를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 방식
  - Man Month: 한 사람이 1개월 동안 할 수 있는 일의 양을 기준으로 프로젝트 비용을 산정하는 방식
  - COCOMO 모형: 보헴, 비용산정 결과는 프로젝트를 완성하는 데 필요한 노력으로 산정
    - 조직형: 5만 라인 이하 
    - 반 분리형: 30만 라인 이하 
    - 임베디드형: 30만 라인 초과 
  - Putnam 모형: 생명주기 예측 모형, 각 단계별로 요구할 인력의 분포를 가정하는 방식
  - FP 모형: 요구 기능을 증가시키는 인자별로 가중치를 부여하고, 요인별 가중치를 합산하여 총 기능의 점수를 계산하여 비용을 산정하는 방식

## 일정 관리 모델
- 프로젝트가 일정 기한 내에 적절하게 완료도리 수 있도록 관리하는 모델
- 주 공정법(CPM): 여러가지 수행 순서가 얽혀 있는 프로젝트의 일정을 계산하는 방법, 가장 긴 시간이 걸리는 경로를 계산한다.
- PERT(Program Evaluation and Review Technique): 일의 순서를 계획적으로 정리하기 위한 수렴 기법 3점 추정방식을 통해 일정을 관리하는 기법
- 중요 연쇄 프로젝트 관리(CCPM): 주 공정 연쇄법으로 자원 제약 사항을 고려하여 일정을 작성하는 기법

## 소프트웨어 아키텍쳐 4+1뷰
- 고객의 요구사항을 정리해 놓은 시나리오를 4개의 관점에서 바라보는 소프트웨어적인 접근 방식
- 체크 방법으로 유스케이스를 사용한다.
  - 유스케이스: 시스템이 엑터에게 제공해야 하는 기능으로서 시스템의 요구사항이자, 사용자 입장에서 바라본 시스템의 기능 
- 1(유스케이스 뷰) + 4(논리 뷰, 프로세스 뷰, 구현 뷰, 배포 뷰)
- 유스케이스 뷰: 유스케이스 또는 아키텍처를 도출하고 설계하며 다른 뷰를 검증하는데 사용되는 뷰
  - 사용자/설계자/개발자/테스트 관점 
- 논리 뷰: 시스템의 기능적인 요구사항이 어떻게 제공되는지 설명해주는 뷰
  - 설계자/개발자 관점
- 프로세스 뷰: 시스템의 비기능적인 속성으로서 자원의 효율적인 사용, 병행 실행, 비동기, 이벤트 처리 등을 표현한 뷰
  - 개발자/시스템 통합자 관점
- 구현 뷰: 개발 환경 안에서 정적인 소프트웨어 모듈의 구성을 보여주는 뷰
- 배포 뷰: 컴포넌트가 물리적인 아키텍처에 어떻게 배치되는가를 매핑해주는 뷰

## 소프트웨어 아키텍처 패턴
- 소프트웨어를 설계할 때 참조할 수 있는 전형적인 해결 방식
- 계층화 패턴: 시스템을 계층으로 구분하여 구성하는 패턴
- 클라이언트-서버 패턴: 하나의 서버와 다수의 클라이언트로 구성된 패턴
- 파이프-필터 패턴: 데이터 스트림을 생성하고 처리하는 시스템에서 사용 가능한 패턴
- 브로커 패턴: 분리된 컴포넌트들로 이루어진 분산 시스템에서 사용되고, 이 컴포넌트들은 원격 서비스 실행을 통해 상호 작용이 가능한 패턴
- 모델-뷰-컨트롤러 패턴: 대화형 어플리케이션을 모델, 뷰, 컨트롤러의 3개의 서비 시스템으로 구조화하는 패턴

## 소프트웨어 아키텍처 비용 평가 모델
- 아키텍처 접근벙이 품질 속성에 미치는 영향을 판단하고 아키텍처의 적합성을 평가하는 모델
- SACAA
  - SAAM: 변경 용이성과 기능성에 집중, 평가가 용이하며 경험이 없는 조직에서도 활용 가능한 비용 평가 모델
  - ATAM: 아키텍처 품질 속성을 만족시키는지 판단 및 품질 속성들의 이해 상충관계가지 평가하는 모델
  - CBAM: ATAM 바탕의 시스템 아키텍처 분석 중심으로 경제적 의사결정에 대한 요구를 충족하는 비용 평가 모델
  - ADR: 소프트웨어 아키텍처 구성요소 간 응집도를 평가하는 모델
  - ARID: 전체 아키첵처가 아닌 특정 부분에 대한 품질요소에 집중하는 비용 평가 모델

## 디자인 패턴
- 소프트웨어 공학의 스프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 패턴
- 디자인 패턴의 구성요소 
  - 패턴의 이름
  - 문제 및 배경
  - 솔루션
  - 사례
  - 결과 
  - 샘플코드
- 디자인 패턴 유형
  - 목적에 따른 구분: 생성, 구조, 행위
  - 범위에 따른 구분: 클래스, 객체
  - 생성 패턴: 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행하는 패턴
    - Builder: 복잡한 인스턴스를 조립하여 만드는 구조
    - Prototype: 처음부터 일반적인 원형을 만들어 놓고, 그것을 복사한 후 필요한 부분만 수정하여 사용하는 패턴
    - Factory Method: 상위 클래스에서 객체를 생헝하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 하는 방식
    - Abstract Factory: 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴
    - Singleton: 전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객첼르 어디에서든지 참조할 수 있도록 하는 패턴
  - 구조 패턴: 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴
    - Bridge: 기능의 클래스 계층과 구현의 클래스 계층을 연결하고, 구현부에서 추상 계층을 분리하여 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있는 패턴
    - Decorator: 기존에 구현되어 있는 클래스에 필요한 기능을 추가해 나가는 패턴
    - Facade: 단순한 인터페이스를 제공함으로서, 노드 간 결합도를 낮추어 시스템 구조에 대한 파악을 쉽게 하는 패턴
    - Flyweight: 클래스 경량화를 목적으로 하는 패턴, 여러 개의 가상 인스턴스를 제공하여 메모리를 절감
    - Proxy: 실제 객체에 대한 대리 객체, 실제 객체 접근 이전에 필요한 행동을 할 수 있음. 정보 은닉의 역할도 수행하는 패턴
    - Composite: 객체들의 관계를 트리 구조로 구성하여, 부분-전체 계층을 표현하는 패턴
    - Adapter: 기존에 생성된 클래스를 재사용 할 수 있도록 중간에서 맞춰주는 역할을 하는 인터페이스를 만드는 패턴
  - 행위 패턴: 클래스나 객체들이 상호 작용하는 방법과 역할 분담을 다루는 패턴
    - Mediator: 중재자를 두고, 중재자에게 모든 것을 요구하여 통신의 빈도수를 줄여 객체 지향의 목표를 달성하는 패턴
    - Interpreter: 구체적으로 구문을 나누고 그 분리된 구문의 해석을 맡는 클래스를 작성하여 여러 형태의 구문을 해석할 수 있게 하는 패턴
    - Iterator: 컬렉션의 구현 방법을 노출시키지 않으면서 안에 들어있는 모든 항목에 접근할 방법을 제공하는 디자인 패턴
    - Template Method: 작업의 일부분을 서브 클래스로 캡슐화 하여 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴
    - Observer: 일대 다의 의존성을 가지며, 상호 작용을 하는 객체 사이에서는 가능하면 느슨하게 결합하는 패턴
    - State: 객체 상태를 캡슐화하여 클래스화 함.
    - Visitor: 각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도의 클래스를 만들고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 하는 패턴
    - Command: 각 명령이 들어오면 그에 맞는 서브 클래스가 선택되어 실행되는 특징을 갖는 패턴
    - Strategy: 알고리즘 군을 정의하고, 같은 알고리즘을 각각의 클래스로 캡슐화한 다음, 필요할 때 서로 교환해서 사용할 수 있게 하는 패턴
    - Memento: 클래스 설계 관점에서 객체의 정보를 저장할 필요가 있을 때 적용하는 패턴
    - Chain of Responsibility: 연결되어 있는 경우에 따라 동적으로 다르게 처리될 수 있도록 연결한 패턴

## 분석 산출물의 종류
- 정보 시스템 구성 현황
- 정보 시스템 기능 구성도
- 인터페이스 현황
- 현행 시스템 아키텍처 구성도
- 소프트웨어 구성도
- 하드웨어 구성도
- 네트워크 구성도

## OS 
- 컴퓨터 시스템이 제공하는 모든 하드웨어, 소프트웨어를 사용할 수 있게 해주고, 사용자와 하드웨어 간의 인터페이스를 담당하는 프로그램
